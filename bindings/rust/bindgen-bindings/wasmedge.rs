/* automatically generated by rust-bindgen 0.59.1 */

pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const WASMEDGE_VERSION: &'static [u8; 22usize] = b"0.8.2-rc.5-1-g809c746\0";
pub const WASMEDGE_VERSION_MAJOR: u32 = 0;
pub const WASMEDGE_VERSION_MINOR: u32 = 8;
pub const WASMEDGE_VERSION_PATCH: u32 = 2;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub const P_ALL: idtype_t = 0;
pub const P_PID: idtype_t = 1;
pub const P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub const WasmEdge_ErrCode_Success: WasmEdge_ErrCode = 0;
#[doc = " Exit and return success."]
pub const WasmEdge_ErrCode_Terminated: WasmEdge_ErrCode = 1;
#[doc = " Generic runtime error."]
pub const WasmEdge_ErrCode_RuntimeError: WasmEdge_ErrCode = 2;
#[doc = " Exceeded cost limit (out of gas)."]
pub const WasmEdge_ErrCode_CostLimitExceeded: WasmEdge_ErrCode = 3;
#[doc = " Wrong VM's workflow"]
pub const WasmEdge_ErrCode_WrongVMWorkflow: WasmEdge_ErrCode = 4;
#[doc = " Wasm function not found"]
pub const WasmEdge_ErrCode_FuncNotFound: WasmEdge_ErrCode = 5;
#[doc = " AOT runtime is disabled"]
pub const WasmEdge_ErrCode_AOTDisabled: WasmEdge_ErrCode = 6;
#[doc = " Load phase"]
#[doc = " File not found"]
pub const WasmEdge_ErrCode_InvalidPath: WasmEdge_ErrCode = 32;
#[doc = " Error when reading"]
pub const WasmEdge_ErrCode_ReadError: WasmEdge_ErrCode = 33;
#[doc = " Reach end of file when reading"]
pub const WasmEdge_ErrCode_UnexpectedEnd: WasmEdge_ErrCode = 34;
#[doc = " Not detected magic header"]
pub const WasmEdge_ErrCode_InvalidMagic: WasmEdge_ErrCode = 35;
#[doc = " Unsupported version"]
pub const WasmEdge_ErrCode_InvalidVersion: WasmEdge_ErrCode = 36;
#[doc = " Malformed section ID"]
pub const WasmEdge_ErrCode_InvalidSection: WasmEdge_ErrCode = 37;
#[doc = " Section size mismatched"]
pub const WasmEdge_ErrCode_SectionSizeMismatch: WasmEdge_ErrCode = 38;
#[doc = " Name size out of bounds"]
pub const WasmEdge_ErrCode_NameSizeOutOfBounds: WasmEdge_ErrCode = 39;
#[doc = " Junk sections"]
pub const WasmEdge_ErrCode_JunkSection: WasmEdge_ErrCode = 40;
#[doc = " Incompatible function and code section"]
pub const WasmEdge_ErrCode_IncompatibleFuncCode: WasmEdge_ErrCode = 41;
#[doc = " Incompatible data and datacount section"]
pub const WasmEdge_ErrCode_IncompatibleDataCount: WasmEdge_ErrCode = 42;
#[doc = " Datacount section required"]
pub const WasmEdge_ErrCode_DataCountRequired: WasmEdge_ErrCode = 43;
#[doc = " Malformed import kind"]
pub const WasmEdge_ErrCode_InvalidImportKind: WasmEdge_ErrCode = 44;
#[doc = " Malformed export kind"]
pub const WasmEdge_ErrCode_InvalidExportKind: WasmEdge_ErrCode = 45;
#[doc = " Not loaded an expected zero byte"]
pub const WasmEdge_ErrCode_ExpectedZeroByte: WasmEdge_ErrCode = 46;
#[doc = " Malformed mutability"]
pub const WasmEdge_ErrCode_InvalidMut: WasmEdge_ErrCode = 47;
#[doc = " Local size too large"]
pub const WasmEdge_ErrCode_TooManyLocals: WasmEdge_ErrCode = 48;
#[doc = " Malformed value type"]
pub const WasmEdge_ErrCode_InvalidValType: WasmEdge_ErrCode = 49;
#[doc = " Malformed element type (Bulk-mem proposal)"]
pub const WasmEdge_ErrCode_InvalidElemType: WasmEdge_ErrCode = 50;
#[doc = " Malformed reference type (Ref-types proposal)"]
pub const WasmEdge_ErrCode_InvalidRefType: WasmEdge_ErrCode = 51;
#[doc = " Invalid utf-8 encoding"]
pub const WasmEdge_ErrCode_InvalidUTF8: WasmEdge_ErrCode = 52;
#[doc = " Invalid too large integer"]
pub const WasmEdge_ErrCode_IntegerTooLarge: WasmEdge_ErrCode = 53;
#[doc = " Invalid presentation too long integer"]
pub const WasmEdge_ErrCode_IntegerTooLong: WasmEdge_ErrCode = 54;
#[doc = " Illegal OpCode"]
pub const WasmEdge_ErrCode_InvalidOpCode: WasmEdge_ErrCode = 55;
#[doc = " Parsing error"]
pub const WasmEdge_ErrCode_InvalidGrammar: WasmEdge_ErrCode = 56;
#[doc = " Validation phase"]
#[doc = " Alignment > natural"]
pub const WasmEdge_ErrCode_InvalidAlignment: WasmEdge_ErrCode = 64;
#[doc = " Got unexpected type when checking"]
pub const WasmEdge_ErrCode_TypeCheckFailed: WasmEdge_ErrCode = 65;
#[doc = " Branch to unknown label index"]
pub const WasmEdge_ErrCode_InvalidLabelIdx: WasmEdge_ErrCode = 66;
#[doc = " Access unknown local index"]
pub const WasmEdge_ErrCode_InvalidLocalIdx: WasmEdge_ErrCode = 67;
#[doc = " Type index not defined"]
pub const WasmEdge_ErrCode_InvalidFuncTypeIdx: WasmEdge_ErrCode = 68;
#[doc = " Function index not defined"]
pub const WasmEdge_ErrCode_InvalidFuncIdx: WasmEdge_ErrCode = 69;
#[doc = " Table index not defined"]
pub const WasmEdge_ErrCode_InvalidTableIdx: WasmEdge_ErrCode = 70;
#[doc = " Memory index not defined"]
pub const WasmEdge_ErrCode_InvalidMemoryIdx: WasmEdge_ErrCode = 71;
#[doc = " Global index not defined"]
pub const WasmEdge_ErrCode_InvalidGlobalIdx: WasmEdge_ErrCode = 72;
#[doc = " Element segment index not defined"]
pub const WasmEdge_ErrCode_InvalidElemIdx: WasmEdge_ErrCode = 73;
#[doc = " Data segment index not defined"]
pub const WasmEdge_ErrCode_InvalidDataIdx: WasmEdge_ErrCode = 74;
#[doc = " Undeclared reference"]
pub const WasmEdge_ErrCode_InvalidRefIdx: WasmEdge_ErrCode = 75;
#[doc = " Should be constant expression"]
pub const WasmEdge_ErrCode_ConstExprRequired: WasmEdge_ErrCode = 76;
#[doc = " Export name conflicted"]
pub const WasmEdge_ErrCode_DupExportName: WasmEdge_ErrCode = 77;
#[doc = " Tried to store to const global value"]
pub const WasmEdge_ErrCode_ImmutableGlobal: WasmEdge_ErrCode = 78;
#[doc = " Invalid result arity in select t* instruction"]
pub const WasmEdge_ErrCode_InvalidResultArity: WasmEdge_ErrCode = 79;
#[doc = " #Tables > 1 (without Ref-types proposal)"]
pub const WasmEdge_ErrCode_MultiTables: WasmEdge_ErrCode = 80;
#[doc = " #Memories > 1"]
pub const WasmEdge_ErrCode_MultiMemories: WasmEdge_ErrCode = 81;
#[doc = " Invalid Limit grammar"]
pub const WasmEdge_ErrCode_InvalidLimit: WasmEdge_ErrCode = 82;
#[doc = " Memory pages > 65536"]
pub const WasmEdge_ErrCode_InvalidMemPages: WasmEdge_ErrCode = 83;
#[doc = " Invalid start function signature"]
pub const WasmEdge_ErrCode_InvalidStartFunc: WasmEdge_ErrCode = 84;
#[doc = " Invalid lane index"]
pub const WasmEdge_ErrCode_InvalidLaneIdx: WasmEdge_ErrCode = 85;
#[doc = " Instantiation phase"]
#[doc = " Module name conflicted when importing."]
pub const WasmEdge_ErrCode_ModuleNameConflict: WasmEdge_ErrCode = 96;
#[doc = " Import matching failed"]
pub const WasmEdge_ErrCode_IncompatibleImportType: WasmEdge_ErrCode = 97;
#[doc = " Unknown import instances"]
pub const WasmEdge_ErrCode_UnknownImport: WasmEdge_ErrCode = 98;
#[doc = " Init failed when instantiating data segment"]
pub const WasmEdge_ErrCode_DataSegDoesNotFit: WasmEdge_ErrCode = 99;
#[doc = " Init failed when instantiating element segment"]
pub const WasmEdge_ErrCode_ElemSegDoesNotFit: WasmEdge_ErrCode = 100;
#[doc = " Execution phase"]
#[doc = " Wrong access of instances addresses"]
pub const WasmEdge_ErrCode_WrongInstanceAddress: WasmEdge_ErrCode = 128;
#[doc = " Wrong access of instances indices"]
pub const WasmEdge_ErrCode_WrongInstanceIndex: WasmEdge_ErrCode = 129;
#[doc = " Instruction type not match"]
pub const WasmEdge_ErrCode_InstrTypeMismatch: WasmEdge_ErrCode = 130;
#[doc = " Function signature not match when invoking"]
pub const WasmEdge_ErrCode_FuncSigMismatch: WasmEdge_ErrCode = 131;
#[doc = " Divide by zero"]
pub const WasmEdge_ErrCode_DivideByZero: WasmEdge_ErrCode = 132;
#[doc = " Integer overflow"]
pub const WasmEdge_ErrCode_IntegerOverflow: WasmEdge_ErrCode = 133;
#[doc = " Cannot do convert to integer"]
pub const WasmEdge_ErrCode_InvalidConvToInt: WasmEdge_ErrCode = 134;
#[doc = " Out of bounds table access"]
pub const WasmEdge_ErrCode_TableOutOfBounds: WasmEdge_ErrCode = 135;
#[doc = " Out of bounds memory access"]
pub const WasmEdge_ErrCode_MemoryOutOfBounds: WasmEdge_ErrCode = 136;
#[doc = " Meet an unreachable instruction"]
pub const WasmEdge_ErrCode_Unreachable: WasmEdge_ErrCode = 137;
#[doc = " Uninitialized element in table instance"]
pub const WasmEdge_ErrCode_UninitializedElement: WasmEdge_ErrCode = 138;
#[doc = " Access undefined element in table instances"]
pub const WasmEdge_ErrCode_UndefinedElement: WasmEdge_ErrCode = 139;
#[doc = " Func type mismatch in call_indirect"]
pub const WasmEdge_ErrCode_IndirectCallTypeMismatch: WasmEdge_ErrCode = 140;
#[doc = " Host function execution failed"]
pub const WasmEdge_ErrCode_ExecutionFailed: WasmEdge_ErrCode = 141;
#[doc = " Reference type not match"]
pub const WasmEdge_ErrCode_RefTypeMismatch: WasmEdge_ErrCode = 142;
#[doc = " Error code enumeration."]
pub type WasmEdge_ErrCode = ::std::os::raw::c_uint;
pub const WasmEdge_ValType_I32: WasmEdge_ValType = 127;
pub const WasmEdge_ValType_I64: WasmEdge_ValType = 126;
pub const WasmEdge_ValType_F32: WasmEdge_ValType = 125;
pub const WasmEdge_ValType_F64: WasmEdge_ValType = 124;
pub const WasmEdge_ValType_V128: WasmEdge_ValType = 123;
pub const WasmEdge_ValType_FuncRef: WasmEdge_ValType = 112;
pub const WasmEdge_ValType_ExternRef: WasmEdge_ValType = 111;
#[doc = " WASM Value type enumeration."]
pub type WasmEdge_ValType = ::std::os::raw::c_uint;
pub const WasmEdge_RefType_FuncRef: WasmEdge_RefType = 112;
pub const WasmEdge_RefType_ExternRef: WasmEdge_RefType = 111;
#[doc = " WASM Reference type enumeration."]
pub type WasmEdge_RefType = ::std::os::raw::c_uint;
pub const WasmEdge_Mutability_Const: WasmEdge_Mutability = 0;
pub const WasmEdge_Mutability_Var: WasmEdge_Mutability = 1;
#[doc = " WASM Mutability enumeration."]
pub type WasmEdge_Mutability = ::std::os::raw::c_uint;
#[doc = " WasmEdge WASM value struct."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Value {
    pub Value: u128,
    #[doc = " The value type is used in the parameters of invoking functions. For the"]
    #[doc = " return values of invoking functions, this member will always be"]
    #[doc = " `WasmEdge_ValType_I32`. Users should use APIs to retrieve the WASM"]
    #[doc = " function's `WasmEdge_FunctionTypeContext` to get the actual return list"]
    #[doc = " value types, and then use the corresponding `WasmEdge_ValueGet` functions"]
    #[doc = " to retrieve the value."]
    pub Type: WasmEdge_ValType,
}
#[test]
fn bindgen_test_layout_WasmEdge_Value() {
    assert_eq!(
        ::std::mem::size_of::<WasmEdge_Value>(),
        32usize,
        concat!("Size of: ", stringify!(WasmEdge_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<WasmEdge_Value>(),
        16usize,
        concat!("Alignment of ", stringify!(WasmEdge_Value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Value>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Value),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Value>())).Type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Value),
            "::",
            stringify!(Type)
        )
    );
}
#[doc = " WasmEdge string struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_String {
    pub Length: u32,
    pub Buf: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_WasmEdge_String() {
    assert_eq!(
        ::std::mem::size_of::<WasmEdge_String>(),
        16usize,
        concat!("Size of: ", stringify!(WasmEdge_String))
    );
    assert_eq!(
        ::std::mem::align_of::<WasmEdge_String>(),
        8usize,
        concat!("Alignment of ", stringify!(WasmEdge_String))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_String>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_String),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_String>())).Buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_String),
            "::",
            stringify!(Buf)
        )
    );
}
#[doc = " Opaque struct of WASM execution result."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Result {
    pub Code: u8,
}
#[test]
fn bindgen_test_layout_WasmEdge_Result() {
    assert_eq!(
        ::std::mem::size_of::<WasmEdge_Result>(),
        1usize,
        concat!("Size of: ", stringify!(WasmEdge_Result))
    );
    assert_eq!(
        ::std::mem::align_of::<WasmEdge_Result>(),
        1usize,
        concat!("Alignment of ", stringify!(WasmEdge_Result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Result>())).Code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Result),
            "::",
            stringify!(Code)
        )
    );
}
#[doc = " Struct of WASM limit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_Limit {
    #[doc = " Boolean to describe has max value or not."]
    pub HasMax: bool,
    #[doc = " Minimum value."]
    pub Min: u32,
    #[doc = " Maximum value. Will be ignored if the `HasMax` is false."]
    pub Max: u32,
}
#[test]
fn bindgen_test_layout_WasmEdge_Limit() {
    assert_eq!(
        ::std::mem::size_of::<WasmEdge_Limit>(),
        12usize,
        concat!("Size of: ", stringify!(WasmEdge_Limit))
    );
    assert_eq!(
        ::std::mem::align_of::<WasmEdge_Limit>(),
        4usize,
        concat!("Alignment of ", stringify!(WasmEdge_Limit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Limit>())).HasMax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Limit),
            "::",
            stringify!(HasMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Limit>())).Min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Limit),
            "::",
            stringify!(Min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WasmEdge_Limit>())).Max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WasmEdge_Limit),
            "::",
            stringify!(Max)
        )
    );
}
pub const WasmEdge_Proposal_BulkMemoryOperations: WasmEdge_Proposal = 0;
pub const WasmEdge_Proposal_ReferenceTypes: WasmEdge_Proposal = 1;
pub const WasmEdge_Proposal_SIMD: WasmEdge_Proposal = 2;
pub const WasmEdge_Proposal_TailCall: WasmEdge_Proposal = 3;
pub const WasmEdge_Proposal_Annotations: WasmEdge_Proposal = 4;
pub const WasmEdge_Proposal_Memory64: WasmEdge_Proposal = 5;
pub const WasmEdge_Proposal_Threads: WasmEdge_Proposal = 6;
pub const WasmEdge_Proposal_ExceptionHandling: WasmEdge_Proposal = 7;
pub const WasmEdge_Proposal_FunctionReferences: WasmEdge_Proposal = 8;
#[doc = " WASM Proposal enumeration."]
#[doc = " This enum is copied from \"include/common/configure.h\" and should be the"]
#[doc = " same."]
pub type WasmEdge_Proposal = ::std::os::raw::c_uint;
pub const WasmEdge_HostRegistration_Wasi: WasmEdge_HostRegistration = 0;
pub const WasmEdge_HostRegistration_WasmEdge_Process: WasmEdge_HostRegistration = 1;
#[doc = " Host Module Registration enumeration."]
pub type WasmEdge_HostRegistration = ::std::os::raw::c_uint;
#[doc = " Disable as many optimizations as possible."]
pub const WasmEdge_CompilerOptimizationLevel_O0: WasmEdge_CompilerOptimizationLevel = 0;
#[doc = " Optimize quickly without destroying debuggability."]
pub const WasmEdge_CompilerOptimizationLevel_O1: WasmEdge_CompilerOptimizationLevel = 1;
#[doc = " Optimize for fast execution as much as possible without triggering"]
#[doc = " significant incremental compile time or code size growth."]
pub const WasmEdge_CompilerOptimizationLevel_O2: WasmEdge_CompilerOptimizationLevel = 2;
#[doc = " Optimize for fast execution as much as possible."]
pub const WasmEdge_CompilerOptimizationLevel_O3: WasmEdge_CompilerOptimizationLevel = 3;
#[doc = " Optimize for small code size as much as possible without triggering"]
#[doc = " significant incremental compile time or execution time slowdowns."]
pub const WasmEdge_CompilerOptimizationLevel_Os: WasmEdge_CompilerOptimizationLevel = 4;
#[doc = " Optimize for small code size as much as possible."]
pub const WasmEdge_CompilerOptimizationLevel_Oz: WasmEdge_CompilerOptimizationLevel = 5;
#[doc = " AOT compiler optimization level enumeration."]
pub type WasmEdge_CompilerOptimizationLevel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ConfigureContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_StatisticsContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ASTModuleContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_CompilerContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_LoaderContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ValidatorContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_InterpreterContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_StoreContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_FunctionTypeContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_FunctionInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_HostFunctionContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_TableInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_MemoryInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_GlobalInstanceContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_ImportObjectContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WasmEdge_VMContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the version string of the WasmEdge C API."]
    #[doc = ""]
    #[doc = " The returned string must __NOT__ be freed."]
    #[doc = ""]
    #[doc = " \\returns NULL-terminated C string of version."]
    pub fn WasmEdge_VersionGet() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the major version value of the WasmEdge C API."]
    #[doc = ""]
    #[doc = " \\returns Value of the major version."]
    pub fn WasmEdge_VersionGetMajor() -> u32;
}
extern "C" {
    #[doc = " Get the minor version value of the WasmEdge C API."]
    #[doc = ""]
    #[doc = " \\returns Value of the minor version."]
    pub fn WasmEdge_VersionGetMinor() -> u32;
}
extern "C" {
    #[doc = " Get the patch version value of the WasmEdge C API."]
    #[doc = ""]
    #[doc = " \\returns Value of the patch version."]
    pub fn WasmEdge_VersionGetPatch() -> u32;
}
extern "C" {
    #[doc = " Set the logging system to filter to error level."]
    pub fn WasmEdge_LogSetErrorLevel();
}
extern "C" {
    #[doc = " Set the logging system to filter to debug level."]
    pub fn WasmEdge_LogSetDebugLevel();
}
extern "C" {
    #[doc = " Generate the I32 WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the I32 value."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the I32 value."]
    pub fn WasmEdge_ValueGenI32(Val: i32) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the I64 WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the I64 value."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the I64 value."]
    pub fn WasmEdge_ValueGenI64(Val: i64) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the F32 WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the F32 value."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the F32 value."]
    pub fn WasmEdge_ValueGenF32(Val: f32) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the F64 WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the F64 value."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the F64 value."]
    pub fn WasmEdge_ValueGenF64(Val: f64) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the V128 WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the V128 value."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the V128 value."]
    pub fn WasmEdge_ValueGenV128(Val: i128) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the NULL reference WASM value."]
    #[doc = ""]
    #[doc = " The values generated by this function are only meaningful when the"]
    #[doc = " `WasmEdge_Proposal_BulkMemoryOperations` or the"]
    #[doc = " `WasmEdge_Proposal_ReferenceTypes` turns on in configuration."]
    #[doc = ""]
    #[doc = " \\param T the reference type."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the NULL reference."]
    pub fn WasmEdge_ValueGenNullRef(T: WasmEdge_RefType) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the function reference WASM value."]
    #[doc = ""]
    #[doc = " The values generated by this function are only meaningful when the"]
    #[doc = " `WasmEdge_Proposal_BulkMemoryOperations` or the"]
    #[doc = " `WasmEdge_Proposal_ReferenceTypes` turns on in configuration."]
    #[doc = ""]
    #[doc = " \\param Index the function index."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the function reference."]
    pub fn WasmEdge_ValueGenFuncRef(Index: u32) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Generate the function reference WASM value."]
    #[doc = ""]
    #[doc = " The values generated by this function are only meaningful when the"]
    #[doc = " `WasmEdge_Proposal_ReferenceTypes` turns on in configuration."]
    #[doc = ""]
    #[doc = " \\param Ref the reference to the external object."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Value struct with the external reference."]
    pub fn WasmEdge_ValueGenExternRef(Ref: *mut ::std::os::raw::c_void) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Retrieve the I32 value from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns I32 value in the input struct."]
    pub fn WasmEdge_ValueGetI32(Val: WasmEdge_Value) -> i32;
}
extern "C" {
    #[doc = " Retrieve the I64 value from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns I64 value in the input struct."]
    pub fn WasmEdge_ValueGetI64(Val: WasmEdge_Value) -> i64;
}
extern "C" {
    #[doc = " Retrieve the F32 value from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns F32 value in the input struct."]
    pub fn WasmEdge_ValueGetF32(Val: WasmEdge_Value) -> f32;
}
extern "C" {
    #[doc = " Retrieve the F64 value from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns F64 value in the input struct."]
    pub fn WasmEdge_ValueGetF64(Val: WasmEdge_Value) -> f64;
}
extern "C" {
    #[doc = " Retrieve the V128 value from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns V128 value in the input struct."]
    pub fn WasmEdge_ValueGetV128(Val: WasmEdge_Value) -> i128;
}
extern "C" {
    #[doc = " Specify the WASM value is a null reference or not."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns true if the value is a null reference, false if not."]
    pub fn WasmEdge_ValueIsNullRef(Val: WasmEdge_Value) -> bool;
}
extern "C" {
    #[doc = " Retrieve the function index from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns function index in the input struct."]
    pub fn WasmEdge_ValueGetFuncIdx(Val: WasmEdge_Value) -> u32;
}
extern "C" {
    #[doc = " Retrieve the external reference from the WASM value."]
    #[doc = ""]
    #[doc = " \\param Val the WasmEdge_Value struct."]
    #[doc = ""]
    #[doc = " \\returns external reference in the input struct."]
    pub fn WasmEdge_ValueGetExternRef(Val: WasmEdge_Value) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_String with the C string."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_StringDelete` to free"]
    #[doc = " it. This function only supports the C string with NULL termination. If the"]
    #[doc = " input string may have `\\0` character, please use the"]
    #[doc = " `WasmEdge_StringCreateByBuffer` instead."]
    #[doc = ""]
    #[doc = " \\param Str the NULL-terminated C string to copy into the WasmEdge_String"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " \\returns pointer to the context, NULL if failed."]
    pub fn WasmEdge_StringCreateByCString(Str: *const ::std::os::raw::c_char) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_String with the buffer and its length."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_StringDelete` to free"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\param Buf the buffer to copy into the WasmEdge_String object."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns pointer to the context, NULL if failed."]
    pub fn WasmEdge_StringCreateByBuffer(
        Buf: *const ::std::os::raw::c_char,
        Len: u32,
    ) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Create the WasmEdge_String wraps to the buffer."]
    #[doc = ""]
    #[doc = " This function creates a `WasmEdge_String` object which wraps to the input"]
    #[doc = " buffer. The caller should guarantee the life cycle of the input buffer, and"]
    #[doc = " should __NOT__ call the `WasmEdge_StringDelete`."]
    #[doc = ""]
    #[doc = " \\param Buf the buffer to copy into the WasmEdge_String object."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns pointer to the context, NULL if failed."]
    pub fn WasmEdge_StringWrap(Buf: *const ::std::os::raw::c_char, Len: u32) -> WasmEdge_String;
}
extern "C" {
    #[doc = " Compare the two WasmEdge_String objects."]
    #[doc = ""]
    #[doc = " \\param Str1 the first WasmEdge_String object to compare."]
    #[doc = " \\param Str2 the second WasmEdge_String object to compare."]
    #[doc = ""]
    #[doc = " \\returns true if the content of two WasmEdge_String objects are the same,"]
    #[doc = " false if not."]
    pub fn WasmEdge_StringIsEqual(Str1: WasmEdge_String, Str2: WasmEdge_String) -> bool;
}
extern "C" {
    #[doc = " Copy the content of WasmEdge_String object to the buffer."]
    #[doc = ""]
    #[doc = " This function copy at most `Len` characters from the `WasmEdge_String`"]
    #[doc = " object to the destination buffer. If the string length is less than `Len`"]
    #[doc = " characters long, the remainder of the buffer is filled with `\\0' characters."]
    #[doc = " Otherwise, the destination is not terminated."]
    #[doc = ""]
    #[doc = " \\param Str the source WasmEdge_String object to copy."]
    #[doc = " \\param Buf the buffer to fill the string content."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns the copied length of string."]
    pub fn WasmEdge_StringCopy(
        Str: WasmEdge_String,
        Buf: *mut ::std::os::raw::c_char,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_String."]
    #[doc = ""]
    #[doc = " After calling this function, the resources in the WasmEdge_String object"]
    #[doc = " will be released and the object should __NOT__ be used."]
    #[doc = ""]
    #[doc = " \\param Str the WasmEdge_String object to delete."]
    pub fn WasmEdge_StringDelete(Str: WasmEdge_String);
}
extern "C" {
    #[doc = " Check the result is a success or not."]
    #[doc = ""]
    #[doc = " \\param Res the WasmEdge_Result struct."]
    #[doc = ""]
    #[doc = " \\returns true if the error code is WasmEdge_Result_Success or"]
    #[doc = " WasmEdge_Result_Terminate, false for others."]
    pub fn WasmEdge_ResultOK(Res: WasmEdge_Result) -> bool;
}
extern "C" {
    #[doc = " Get the result code."]
    #[doc = ""]
    #[doc = " \\param Res the WasmEdge_Result struct."]
    #[doc = ""]
    #[doc = " \\returns corresponding result code."]
    pub fn WasmEdge_ResultGetCode(Res: WasmEdge_Result) -> u32;
}
extern "C" {
    #[doc = " Get the result message."]
    #[doc = ""]
    #[doc = " The returned string must __NOT__ be freed."]
    #[doc = ""]
    #[doc = " \\param Res the WasmEdge_Result struct."]
    #[doc = ""]
    #[doc = " \\returns NULL-terminated C string of the corresponding error message."]
    pub fn WasmEdge_ResultGetMessage(Res: WasmEdge_Result) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_ConfigureDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\returns pointer to the context, NULL if failed."]
    pub fn WasmEdge_ConfigureCreate() -> *mut WasmEdge_ConfigureContext;
}
extern "C" {
    #[doc = " Add a proposal setting into the WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " For turning on a specific WASM proposal in WasmEdge_VMContext, you can set"]
    #[doc = " the proposal value into the WasmEdge_ConfigureContext and create VM with"]
    #[doc = " this context."]
    #[doc = " ```c"]
    #[doc = " WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();"]
    #[doc = " WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_BulkMemoryOperations);"]
    #[doc = " WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_ReferenceTypes);"]
    #[doc = " WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_SIMD);"]
    #[doc = " WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to add the proposal value."]
    #[doc = " \\param Prop the proposal value."]
    pub fn WasmEdge_ConfigureAddProposal(
        Cxt: *mut WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    );
}
extern "C" {
    #[doc = " Remove a proposal setting in the WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to remove the proposal."]
    #[doc = " \\param Prop the proposal value."]
    pub fn WasmEdge_ConfigureRemoveProposal(
        Cxt: *mut WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    );
}
extern "C" {
    #[doc = " Check if a proposal setting exists in the WasmEdge_ConfigureContext or not."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to check the proposal value."]
    #[doc = " \\param Prop the proposal value."]
    #[doc = ""]
    #[doc = " \\returns true if the proposal setting exists, false if not."]
    pub fn WasmEdge_ConfigureHasProposal(
        Cxt: *const WasmEdge_ConfigureContext,
        Prop: WasmEdge_Proposal,
    ) -> bool;
}
extern "C" {
    #[doc = " Add a host pre-registration setting into WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " For turning on the Wasi support in `WasmEdge_VMContext`, you can set the"]
    #[doc = " host pre-registration value into the `WasmEdge_ConfigureContext` and create"]
    #[doc = " VM with this context."]
    #[doc = " ```c"]
    #[doc = " WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();"]
    #[doc = " WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);"]
    #[doc = " WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to add host pre-registration."]
    #[doc = " \\param Host the host pre-registration value."]
    pub fn WasmEdge_ConfigureAddHostRegistration(
        Cxt: *mut WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    );
}
extern "C" {
    #[doc = " Remove a host pre-registration setting in the WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to remove the host"]
    #[doc = " pre-registration. \\param Host the host pre-registration value."]
    pub fn WasmEdge_ConfigureRemoveHostRegistration(
        Cxt: *mut WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    );
}
extern "C" {
    #[doc = " Check if a host pre-registration setting exists in the"]
    #[doc = " WasmEdge_ConfigureContext or not."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to check the host pre-registration."]
    #[doc = " \\param Host the host pre-registration value."]
    #[doc = ""]
    #[doc = " \\returns true if the host pre-registration setting exists, false if not."]
    pub fn WasmEdge_ConfigureHasHostRegistration(
        Cxt: *const WasmEdge_ConfigureContext,
        Host: WasmEdge_HostRegistration,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the page limit of memory instances."]
    #[doc = ""]
    #[doc = " Limit the page count (64KiB per page) in memory instances."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to set the maximum page count."]
    #[doc = " \\param Page the maximum page count."]
    pub fn WasmEdge_ConfigureSetMaxMemoryPage(Cxt: *mut WasmEdge_ConfigureContext, Page: u32);
}
extern "C" {
    #[doc = " Get the page limit of memory instances."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to get the maximum page count"]
    #[doc = " setting."]
    #[doc = ""]
    #[doc = " \\returns the page count limitation value."]
    pub fn WasmEdge_ConfigureGetMaxMemoryPage(Cxt: *const WasmEdge_ConfigureContext) -> u32;
}
extern "C" {
    #[doc = " Set the optimization level of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to set the optimization level."]
    #[doc = " \\param Level the AOT compiler optimization level."]
    pub fn WasmEdge_ConfigureCompilerSetOptimizationLevel(
        Cxt: *mut WasmEdge_ConfigureContext,
        Level: WasmEdge_CompilerOptimizationLevel,
    );
}
extern "C" {
    #[doc = " Get the optimization level of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to get the optimization level."]
    #[doc = ""]
    #[doc = " \\returns the AOT compiler optimization level."]
    pub fn WasmEdge_ConfigureCompilerGetOptimizationLevel(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> WasmEdge_CompilerOptimizationLevel;
}
extern "C" {
    #[doc = " Set the dump IR boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to set the boolean value."]
    #[doc = " \\param IsDump the boolean value to determine to dump IR or not when"]
    #[doc = " compilation in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetDumpIR(Cxt: *mut WasmEdge_ConfigureContext, IsDump: bool);
}
extern "C" {
    #[doc = " Get the dump IR boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to get the boolean value."]
    #[doc = ""]
    #[doc = " \\returns the boolean value to determine to dump IR or not when compilation"]
    #[doc = " in AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsDumpIR(Cxt: *const WasmEdge_ConfigureContext) -> bool;
}
extern "C" {
    #[doc = " Set the instruction counting supporting boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to set the boolean value."]
    #[doc = " \\param IsCount the boolean value to determine to support instruction"]
    #[doc = " counting when execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetInstructionCounting(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsCount: bool,
    );
}
extern "C" {
    #[doc = " Get the instruction counting supporting boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to get the boolean value."]
    #[doc = ""]
    #[doc = " \\returns the boolean value to determine to support instruction counting when"]
    #[doc = " execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsInstructionCounting(
        Cxt: *const WasmEdge_ConfigureContext,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the cost measuring supporting boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to set the boolean value."]
    #[doc = " \\param IsMeasure the boolean value to determine to support cost measuring"]
    #[doc = " when execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerSetCostMeasuring(
        Cxt: *mut WasmEdge_ConfigureContext,
        IsMeasure: bool,
    );
}
extern "C" {
    #[doc = " Get the cost measuring supporting boolean value of AOT compiler."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to get the boolean value."]
    #[doc = ""]
    #[doc = " \\returns the boolean value to determine to support cost measuring when"]
    #[doc = " execution or not after compilation by the AOT compiler."]
    pub fn WasmEdge_ConfigureCompilerIsCostMeasuring(Cxt: *const WasmEdge_ConfigureContext)
        -> bool;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ConfigureContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ConfigureContext to delete."]
    pub fn WasmEdge_ConfigureDelete(Cxt: *mut WasmEdge_ConfigureContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_StatisticsContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_StatisticsDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_StatisticsCreate() -> *mut WasmEdge_StatisticsContext;
}
extern "C" {
    #[doc = " Get the instruction count in execution."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to get data."]
    #[doc = ""]
    #[doc = " \\returns the instruction count in total execution."]
    pub fn WasmEdge_StatisticsGetInstrCount(Cxt: *const WasmEdge_StatisticsContext) -> u64;
}
extern "C" {
    #[doc = " Get the instruction count per second in execution."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to get data."]
    #[doc = ""]
    #[doc = " \\returns the instruction count per second."]
    pub fn WasmEdge_StatisticsGetInstrPerSecond(Cxt: *const WasmEdge_StatisticsContext) -> f64;
}
extern "C" {
    #[doc = " Get the total cost in execution."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to get data."]
    #[doc = ""]
    #[doc = " \\returns the total cost."]
    pub fn WasmEdge_StatisticsGetTotalCost(Cxt: *const WasmEdge_StatisticsContext) -> u64;
}
extern "C" {
    #[doc = " Set the costs of instructions."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to set the cost table."]
    #[doc = " \\param CostArr the cost table array."]
    #[doc = " \\param Len the length of the cost table array."]
    pub fn WasmEdge_StatisticsSetCostTable(
        Cxt: *mut WasmEdge_StatisticsContext,
        CostArr: *mut u64,
        Len: u32,
    );
}
extern "C" {
    #[doc = " Set the cost limit in execution."]
    #[doc = ""]
    #[doc = " The WASM execution will be aborted if the instruction costs exceeded the"]
    #[doc = " limit and the ErrCode::CostLimitExceeded will be returned."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to set the cost table."]
    #[doc = " \\param Limit the cost limit."]
    pub fn WasmEdge_StatisticsSetCostLimit(Cxt: *mut WasmEdge_StatisticsContext, Limit: u64);
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_StatisticsContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StatisticsContext to delete."]
    pub fn WasmEdge_StatisticsDelete(Cxt: *mut WasmEdge_StatisticsContext);
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ASTModuleContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ASTModuleContext to delete."]
    pub fn WasmEdge_ASTModuleDelete(Cxt: *mut WasmEdge_ASTModuleContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_CompilerContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_CompilerDelete` to free"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_CompilerCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_CompilerContext;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_CompilerContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_CompilerDelete` to free"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_CompilerCompile(
        Cxt: *mut WasmEdge_CompilerContext,
        InPath: *const ::std::os::raw::c_char,
        OutPath: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_CompilerContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should"]
    #[doc = " __NOT__ be used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_CompilerContext to delete."]
    pub fn WasmEdge_CompilerDelete(Cxt: *mut WasmEdge_CompilerContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_LoaderContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_LoaderDelete` to free"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of Loader."]
    #[doc = " NULL for the default configuration."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_LoaderCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_LoaderContext;
}
extern "C" {
    #[doc = " Load and parse the WASM module from a WASM file into a"]
    #[doc = " WasmEdge_ASTModuleContext."]
    #[doc = ""]
    #[doc = " Load and parse the WASM module from the file path, and return a"]
    #[doc = " `WasmEdge_ASTModuleContext` as result. The caller owns the"]
    #[doc = " `WasmEdge_ASTModuleContext` object and should call"]
    #[doc = " `WasmEdge_ASTModuleDelete` to free it."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_LoaderContext."]
    #[doc = " \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded."]
    #[doc = " \\param Path the NULL-terminated C string of the WASM file path."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_LoaderParseFromFile(
        Cxt: *mut WasmEdge_LoaderContext,
        Module: *mut *mut WasmEdge_ASTModuleContext,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load and parse the WASM module from a buffer into WasmEdge_ASTModuleContext."]
    #[doc = ""]
    #[doc = " Load and parse the WASM module from a buffer, and return a"]
    #[doc = " WasmEdge_ASTModuleContext as result. The caller owns the"]
    #[doc = " WasmEdge_ASTModuleContext object and should call `WasmEdge_ASTModuleDelete`"]
    #[doc = " to free it."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_LoaderContext."]
    #[doc = " \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded."]
    #[doc = " \\param Buf the buffer of WASM binary."]
    #[doc = " \\param BufLen the length of the buffer."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_LoaderParseFromBuffer(
        Cxt: *mut WasmEdge_LoaderContext,
        Module: *mut *mut WasmEdge_ASTModuleContext,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_LoaderContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_LoaderContext to delete."]
    pub fn WasmEdge_LoaderDelete(Cxt: *mut WasmEdge_LoaderContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ValidatorContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_ValidatorDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of"]
    #[doc = " Validator. NULL for the default configuration."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ValidatorCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
    ) -> *mut WasmEdge_ValidatorContext;
}
extern "C" {
    #[doc = " Validate the WasmEdge AST Module."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ValidatorContext."]
    #[doc = " \\param ModuleCxt the WasmEdge_ASTModuleContext to validate."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_ValidatorValidate(
        Cxt: *mut WasmEdge_ValidatorContext,
        ModuleCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ValidatorContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ValidatorContext to delete."]
    pub fn WasmEdge_ValidatorDelete(Cxt: *mut WasmEdge_ValidatorContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_InterpreterContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_InterpreterDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of"]
    #[doc = " Interpreter. NULL for the default configuration."]
    #[doc = " \\param StatCxt the WasmEdge_StatisticsContext as the statistics object set"]
    #[doc = " into Interpreter. The statistics will refer to this context, and the life"]
    #[doc = " cycle should be ensured until the interpreter context is deleted. NULL for"]
    #[doc = " not doing the statistics."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_InterpreterCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
        StatCxt: *mut WasmEdge_StatisticsContext,
    ) -> *mut WasmEdge_InterpreterContext;
}
extern "C" {
    #[doc = " Instantiate WasmEdge AST Module into a store."]
    #[doc = ""]
    #[doc = " Instantiate the WasmEdge AST Module as an active anonymous module in store."]
    #[doc = " You can call `WasmEdge_StoreGetActiveModule` to retrieve the active module"]
    #[doc = " instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext to instantiate the module."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module."]
    #[doc = " \\param ASTCxt the WasmEdge AST Module context generated by loader or"]
    #[doc = " compiler."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_InterpreterInstantiate(
        Cxt: *mut WasmEdge_InterpreterContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WasmEdge import object into a store."]
    #[doc = ""]
    #[doc = " Instantiate the instances in WasmEdge import object context and register"]
    #[doc = " into a store with their exported name and the host module name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext to instantiate the module."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module."]
    #[doc = " \\param ImportCxt the WasmEdge_ImportObjectContext to register."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_InterpreterRegisterImport(
        Cxt: *mut WasmEdge_InterpreterContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ImportCxt: *const WasmEdge_ImportObjectContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WasmEdge AST Module into a store."]
    #[doc = ""]
    #[doc = " Instantiate the instances in WasmEdge AST Module and register into a store"]
    #[doc = " with their exported name and module name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext to instantiate the module."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module."]
    #[doc = " \\param ASTCxt the WasmEdge AST Module context generated by loader or"]
    #[doc = " compiler."]
    #[doc = " \\param ModuleName the module name WasmEdge_String for all exported"]
    #[doc = " instances."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_InterpreterRegisterModule(
        Cxt: *mut WasmEdge_InterpreterContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
        ModuleName: WasmEdge_String,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by name."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered as the"]
    #[doc = " anonymous module in the store context. Then you can repeatedly call this"]
    #[doc = " function to invoke exported WASM functions by their names until the store"]
    #[doc = " context is reset or a new WASM module is registered or instantiated. For"]
    #[doc = " calling the functions in registered WASM modules with names in store, please"]
    #[doc = " use `WasmEdge_InterpreterInvokeRegistered` instead."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext which the module instantiated in."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_InterpreterInvoke(
        Cxt: *mut WasmEdge_InterpreterContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by its module name and function name."]
    #[doc = ""]
    #[doc = " After registering a WASM module, the WASM module is registered with its name"]
    #[doc = " in the store context. Then you can repeatedly call this function to invoke"]
    #[doc = " exported WASM functions by their module names and function names until the"]
    #[doc = " store context is reset."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext which the module instantiated in."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_InterpreterInvokeRegistered(
        Cxt: *mut WasmEdge_InterpreterContext,
        StoreCxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_InterpreterContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_InterpreterContext to delete."]
    pub fn WasmEdge_InterpreterDelete(Cxt: *mut WasmEdge_InterpreterContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_StoreDelete` to free"]
    #[doc = " it."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_StoreCreate() -> *mut WasmEdge_StoreContext;
}
extern "C" {
    #[doc = " Get the function instance context by the function name."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported function instance context of the anonymous module by the"]
    #[doc = " function name. If you want to get the exported function of registered named"]
    #[doc = " modules in the store context, please call"]
    #[doc = " `WasmEdge_StoreFindFunctionRegistered` instead. The result function instance"]
    #[doc = " context links to the function instance in the store context and owned by the"]
    #[doc = " store context."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param Name the function name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the function instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindFunction(
        Cxt: *mut WasmEdge_StoreContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_FunctionInstanceContext;
}
extern "C" {
    #[doc = " Get the function instance context by the function name and the module name."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported function instance context by the module name and the function name."]
    #[doc = " The result function instance context links to the function instance in the"]
    #[doc = " store context and owned by the store context."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the function instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindFunctionRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
    ) -> *mut WasmEdge_FunctionInstanceContext;
}
extern "C" {
    #[doc = " Get the table instance context by the table name."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported table instance context of the anonymous module by the table"]
    #[doc = " name. If you want to get the exported table of registered named modules in"]
    #[doc = " the store context, please call `WasmEdge_StoreFindTableRegistered` instead."]
    #[doc = " The result table instance context links to the table instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_TableInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param Name the table name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the table instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindTable(
        Cxt: *mut WasmEdge_StoreContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_TableInstanceContext;
}
extern "C" {
    #[doc = " Get the table instance context by the table name and the module name."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported table instance context by the module name and the table name."]
    #[doc = " The result table instance context links to the table instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_TableInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param TableName the table name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the table instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindTableRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        TableName: WasmEdge_String,
    ) -> *mut WasmEdge_TableInstanceContext;
}
extern "C" {
    #[doc = " Get the memory instance context by the memory name."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported memory instance context of the anonymous module by the memory"]
    #[doc = " name. If you want to get the exported memory of registered named modules in"]
    #[doc = " the store context, please call `WasmEdge_StoreFindMemoryRegistered` instead."]
    #[doc = " The result memory instance context links to the memory instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_MemoryInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param Name the memory name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the memory instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindMemory(
        Cxt: *mut WasmEdge_StoreContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Get the memory instance context by the memory name and the module name."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported memory instance context by the module name and the memory name."]
    #[doc = " The result memory instance context links to the memory instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_MemoryInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param MemoryName the memory name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the memory instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindMemoryRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        MemoryName: WasmEdge_String,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Get the global instance context by the instance address."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported global instance context of the anonymous module by the global"]
    #[doc = " name. If you want to get the exported global of registered named modules in"]
    #[doc = " the store context, please call `WasmEdge_StoreFindGlobalRegistered` instead."]
    #[doc = " The result global instance context links to the global instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_GlobalInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param Name the global name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the global instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindGlobal(
        Cxt: *mut WasmEdge_StoreContext,
        Name: WasmEdge_String,
    ) -> *mut WasmEdge_GlobalInstanceContext;
}
extern "C" {
    #[doc = " Get the global instance context by the global name and the module name."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported global instance context by the module name and the global name."]
    #[doc = " The result global instance context links to the global instance in the store"]
    #[doc = " context and owned by the store context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_GlobalInstanceDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param GlobalName the global name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns pointer to the global instance context. NULL if not found."]
    pub fn WasmEdge_StoreFindGlobalRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        GlobalName: WasmEdge_String,
    ) -> *mut WasmEdge_GlobalInstanceContext;
}
extern "C" {
    #[doc = " Get the length of exported function list in store."]
    #[doc = ""]
    #[doc = " If you want to get the function list of the registered named modules in the"]
    #[doc = " store context, please call `WasmEdge_StoreListFunctionRegisteredLength`"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " \\returns length of the exported function list."]
    pub fn WasmEdge_StoreListFunctionLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the exported function names."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported function list of the anonymous module. If you want to get the"]
    #[doc = " function list of the registered named modules in the store context, please"]
    #[doc = " call `WasmEdge_StoreListFunctionRegistered` instead."]
    #[doc = " The returned function names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported"]
    #[doc = " function list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the function names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported function list size."]
    pub fn WasmEdge_StoreListFunction(
        Cxt: *mut WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the exported function list length of the registered module in store."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the exported function list length of the module."]
    pub fn WasmEdge_StoreListFunctionRegisteredLength(
        Cxt: *const WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported function names of the registered module."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported function list of the registered module by the module name."]
    #[doc = " The returned function names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported"]
    #[doc = " function list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the function names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported function list size of the module."]
    pub fn WasmEdge_StoreListFunctionRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported table list in store."]
    #[doc = ""]
    #[doc = " If you want to get the table list of the registered named modules in the"]
    #[doc = " store context, please call `WasmEdge_StoreListTableRegisteredLength`"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " \\returns length of the exported table list."]
    pub fn WasmEdge_StoreListTableLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the exported table names."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported table list of the anonymous module. If you want to get the"]
    #[doc = " table list of the registered named modules in the store context, please"]
    #[doc = " call `WasmEdge_StoreListTableRegistered` instead."]
    #[doc = " The returned table names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported table"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the table names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported table list size."]
    pub fn WasmEdge_StoreListTable(
        Cxt: *mut WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the exported table list length of the registered module in store."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the exported table list length of the module."]
    pub fn WasmEdge_StoreListTableRegisteredLength(
        Cxt: *const WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported table names of the registered module."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported table list of the registered module by the module name."]
    #[doc = " The returned table names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported table"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the table names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported table list size of the module."]
    pub fn WasmEdge_StoreListTableRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported memory list in store."]
    #[doc = ""]
    #[doc = " If you want to get the memory list of the registered named modules in the"]
    #[doc = " store context, please call `WasmEdge_StoreListMemoryRegisteredLength`"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " \\returns length of the exported memory list."]
    pub fn WasmEdge_StoreListMemoryLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the exported memory names."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported memory list of the anonymous module. If you want to get the"]
    #[doc = " memory list of the registered named modules in the store context, please"]
    #[doc = " call `WasmEdge_StoreListMemoryRegistered` instead."]
    #[doc = " The returned memory names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported memory"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the memory names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported memory list size."]
    pub fn WasmEdge_StoreListMemory(
        Cxt: *const WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the exported memory list length of the registered module in store."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the exported memory list length of the module."]
    pub fn WasmEdge_StoreListMemoryRegisteredLength(
        Cxt: *const WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported memory names of the registered module."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported memory list of the registered module by the module name."]
    #[doc = " The returned memory names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported memory"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the memory names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported memory list size of the module."]
    pub fn WasmEdge_StoreListMemoryRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of exported global list in store."]
    #[doc = ""]
    #[doc = " If you want to get the global list of the registered named modules in the"]
    #[doc = " store context, please call `WasmEdge_StoreListGlobalRegisteredLength`"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " \\returns length of the exported global list."]
    pub fn WasmEdge_StoreListGlobalLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the exported global names."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module, the WASM module is registered into the"]
    #[doc = " store context as an anonymous module. Then you can call this function to get"]
    #[doc = " the exported global list of the anonymous module. If you want to get the"]
    #[doc = " global list of the registered named modules in the store context, please"]
    #[doc = " call `WasmEdge_StoreListGlobalRegistered` instead."]
    #[doc = " The returned global names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported global"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the global names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported global list size."]
    pub fn WasmEdge_StoreListGlobal(
        Cxt: *const WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the exported global list length of the registered module in store."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the exported global list length of the module."]
    pub fn WasmEdge_StoreListGlobalRegisteredLength(
        Cxt: *const WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
    ) -> u32;
}
extern "C" {
    #[doc = " List the exported global names of the registered module."]
    #[doc = ""]
    #[doc = " After registering a WASM module, you can call this function to get the"]
    #[doc = " exported global list of the registered module by the module name."]
    #[doc = " The returned global names are created and stored into the `Names` array,"]
    #[doc = " and the caller should call the `WasmEdge_StringDelete` to delete them. If"]
    #[doc = " the `Names` buffer length is smaller than the result of the exported global"]
    #[doc = " list size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param [out] Names the output WasmEdge_String buffer of the global names."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported global list size of the module."]
    pub fn WasmEdge_StoreListGlobalRegistered(
        Cxt: *mut WasmEdge_StoreContext,
        ModuleName: WasmEdge_String,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the length of registered module list in store."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " \\returns length of registered named module list."]
    pub fn WasmEdge_StoreListModuleLength(Cxt: *const WasmEdge_StoreContext) -> u32;
}
extern "C" {
    #[doc = " List the registered module names."]
    #[doc = ""]
    #[doc = " This function will list all registered module names."]
    #[doc = " The returned module names are created and stored in `Names` array, and the"]
    #[doc = " caller should call `WasmEdge_StringDelete` to delete them. If the `Names`"]
    #[doc = " buffer length is smaller than the result of the registered named module list"]
    #[doc = " size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext."]
    #[doc = " \\param [out] Names the output names WasmEdge_String buffer of named modules."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual registered named module list size."]
    pub fn WasmEdge_StoreListModule(
        Cxt: *mut WasmEdge_StoreContext,
        Names: *mut WasmEdge_String,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_StoreContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_StoreContext to delete."]
    pub fn WasmEdge_StoreDelete(Cxt: *mut WasmEdge_StoreContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_FunctionTypeDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\param ParamList the value types list of parameters. NULL if the length is"]
    #[doc = " 0."]
    #[doc = " \\param ParamLen the ParamList buffer length."]
    #[doc = " \\param ReturnList the value types list of returns. NULL if the length is 0."]
    #[doc = " \\param ReturnLen the ReturnList buffer length."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionTypeCreate(
        ParamList: *const WasmEdge_ValType,
        ParamLen: u32,
        ReturnList: *const WasmEdge_ValType,
        ReturnLen: u32,
    ) -> *mut WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the parameter types list length from the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " \\returns the parameter types list length."]
    pub fn WasmEdge_FunctionTypeGetParametersLength(
        Cxt: *const WasmEdge_FunctionTypeContext,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the parameter types list from the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " If the `List` buffer length is smaller than the length of the parameter type"]
    #[doc = " list, the overflowed values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionTypeContext."]
    #[doc = " \\param [out] List the WasmEdge_ValType buffer to fill the parameter value"]
    #[doc = " types."]
    #[doc = " \\param Len the value type buffer length."]
    #[doc = ""]
    #[doc = " \\returns the actual parameter types list length."]
    pub fn WasmEdge_FunctionTypeGetParameters(
        Cxt: *const WasmEdge_FunctionTypeContext,
        List: *mut WasmEdge_ValType,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the return types list length from the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " \\returns the return types list length."]
    pub fn WasmEdge_FunctionTypeGetReturnsLength(Cxt: *const WasmEdge_FunctionTypeContext) -> u32;
}
extern "C" {
    #[doc = " Get the return types list from the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " If the `List` buffer length is smaller than the length of the return type"]
    #[doc = " list, the overflowed values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionTypeContext."]
    #[doc = " \\param [out] List the WasmEdge_ValType buffer to fill the return value"]
    #[doc = " types."]
    #[doc = " \\param Len the value type buffer length."]
    #[doc = ""]
    #[doc = " \\returns the actual return types list length."]
    pub fn WasmEdge_FunctionTypeGetReturns(
        Cxt: *const WasmEdge_FunctionTypeContext,
        List: *mut WasmEdge_ValType,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_FunctionTypeContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionTypeContext to delete."]
    pub fn WasmEdge_FunctionTypeDelete(Cxt: *mut WasmEdge_FunctionTypeContext);
}
extern "C" {
    #[doc = " Get the function type context of the function instance."]
    #[doc = ""]
    #[doc = " The function type context links to the function type in the function"]
    #[doc = " instance context and owned by the context. The caller should __NOT__ call"]
    #[doc = " the `WasmEdge_FunctionTypeDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_FunctionInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_FunctionInstanceGetFunctionType(
        Cxt: *const WasmEdge_FunctionInstanceContext,
    ) -> *const WasmEdge_FunctionTypeContext;
}
#[doc = " >>>>>>>> WasmEdge host function functions >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"]
pub type WasmEdge_HostFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        Data: *mut ::std::os::raw::c_void,
        MemCxt: *mut WasmEdge_MemoryInstanceContext,
        Params: *const WasmEdge_Value,
        Returns: *mut WasmEdge_Value,
    ) -> WasmEdge_Result,
>;
extern "C" {
    #[doc = " Creation of the WasmEdge_HostFunctionContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_HostFunctionDelete` to"]
    #[doc = " free it if the returned object is not added into a"]
    #[doc = " `WasmEdge_ImportObjectContext`. The following is an example to create a host"]
    #[doc = " function context."]
    #[doc = " ```c"]
    #[doc = " WasmEdge_Result FuncAdd(void *Data, WasmEdge_MemoryInstanceContext *MemCxt,"]
    #[doc = "                     const WasmEdge_Value *In, WasmEdge_Value *Out) {"]
    #[doc = "   /// Function to return A + B."]
    #[doc = "   int32_t A = WasmEdge_ValueGetI32(In[0]);"]
    #[doc = "   int32_t B = WasmEdge_ValueGetI32(In[1]);"]
    #[doc = "   Out[0] = WasmEdge_ValueGenI32(A + B);"]
    #[doc = "   /// Return execution status"]
    #[doc = "   return WasmEdge_Result_Success;"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,"]
    #[doc = " WasmEdge_ValType_I32}; enum WasmEdge_ValType Returns[1] ="]
    #[doc = " {WasmEdge_ValType_I32}; WasmEdge_FunctionTypeContext *FuncType ="]
    #[doc = "     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);"]
    #[doc = " WasmEdge_HostFunctionContext *HostFunc ="]
    #[doc = "     WasmEdge_HostFunctionCreate(FuncType, FuncAdd, 0);"]
    #[doc = " WasmEdge_FunctionTypeDelete(FuncType);"]
    #[doc = " ..."]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param Type the function type context to describe the host function"]
    #[doc = " signature."]
    #[doc = " \\param HostFunc the host function pointer. The host function signature must"]
    #[doc = " be as following:"]
    #[doc = " ```c"]
    #[doc = " typedef WasmEdge_Result (*WasmEdge_HostFunc_t)("]
    #[doc = "     void *Data,"]
    #[doc = "     WasmEdge_MemoryInstanceContext *MemCxt,"]
    #[doc = "     const WasmEdge_Value *Params,"]
    #[doc = "     WasmEdge_Value *Returns);"]
    #[doc = " ```"]
    #[doc = " The `Data` is the pointer to the data passed into the import object through"]
    #[doc = " `WasmEdge_ImportObjectCreate()`. The `Params` is the input parameters array"]
    #[doc = " with length guaranteed to be the same as the parameter types in the `Type`."]
    #[doc = " The `Returns` is the output results array with length guaranteed to be the"]
    #[doc = " same as the result types in the `Type`. The return value is"]
    #[doc = " `WasmEdge_Result` for the execution status."]
    #[doc = " \\param Cost the function cost in statistics. Pass 0 if the calculation is"]
    #[doc = " not needed."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_HostFunctionCreate(
        Type: *const WasmEdge_FunctionTypeContext,
        HostFunc: WasmEdge_HostFunc_t,
        Cost: u64,
    ) -> *mut WasmEdge_HostFunctionContext;
}
pub type WasmEdge_WrapFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        This: *mut ::std::os::raw::c_void,
        Data: *mut ::std::os::raw::c_void,
        MemCxt: *mut WasmEdge_MemoryInstanceContext,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result,
>;
extern "C" {
    #[doc = " Creation of the WasmEdge_HostFunctionContext."]
    #[doc = ""]
    #[doc = " This function is for the languages which cannot pass the function pointer of"]
    #[doc = " the host function into this shared library directly. The caller owns the"]
    #[doc = " object and should call `WasmEdge_HostFunctionDelete` to free it if the"]
    #[doc = " returned object is not added into a `WasmEdge_ImportObjectContext`. The"]
    #[doc = " following is an example to create a host function context for other"]
    #[doc = " languages."]
    #[doc = " ```c"]
    #[doc = " /// `RealFunc` is the pointer to the function in other languages."]
    #[doc = ""]
    #[doc = " WasmEdge_Result FuncAddWrap(void *This, void *Data,"]
    #[doc = "                             WasmEdge_MemoryInstanceContext *MemCxt,"]
    #[doc = "                             const WasmEdge_Value *In, const uint32_t InLen,"]
    #[doc = "                             WasmEdge_Value *Out, const uint32_t OutLen) {"]
    #[doc = "   /// Wrapper function of host function to return A + B."]
    #[doc = ""]
    #[doc = "   /// `This` is the same as `RealFunc`."]
    #[doc = "   int32_t A = WasmEdge_ValueGetI32(In[0]);"]
    #[doc = "   int32_t B = WasmEdge_ValueGetI32(In[1]);"]
    #[doc = ""]
    #[doc = "   /// Call the function of `This` in the host language ..."]
    #[doc = "   int32_t Result = ...;"]
    #[doc = ""]
    #[doc = "   Out[0] = Result;"]
    #[doc = "   /// Return the execution status"]
    #[doc = "   return WasmEdge_Result_Success;"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " enum WasmEdge_ValType Params[2] ="]
    #[doc = "     { WasmEdge_ValType_I32, WasmEdge_ValType_I32 };"]
    #[doc = " enum WasmEdge_ValType Returns[1] = { WasmEdge_ValType_I32 };"]
    #[doc = " WasmEdge_FunctionTypeContext *FuncType ="]
    #[doc = "     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);"]
    #[doc = " WasmEdge_HostFunctionContext *HostFunc ="]
    #[doc = "     WasmEdge_HostFunctionCreateBinding(FuncType, FuncAddWrap, RealFunc, 0);"]
    #[doc = " WasmEdge_FunctionTypeDelete(FuncType);"]
    #[doc = " ..."]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param Type the function type context to describe the host function"]
    #[doc = " signature."]
    #[doc = " \\param WrapFunc the wrapper function pointer. The wrapper function signature"]
    #[doc = " must be as following:"]
    #[doc = " ```c"]
    #[doc = " typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)("]
    #[doc = "     void *This,"]
    #[doc = "     void *Data,"]
    #[doc = "     WasmEdge_MemoryInstanceContext *MemCxt,"]
    #[doc = "     const WasmEdge_Value *Params,"]
    #[doc = "     const uint32_t ParamLen,"]
    #[doc = "     WasmEdge_Value *Returns,"]
    #[doc = "     const uint32_t ReturnLen);"]
    #[doc = " ```"]
    #[doc = " The `This` is the pointer the same as the `Binding` parameter of this"]
    #[doc = " function. The `Data` is the pointer to the data passed into the import"]
    #[doc = " object through `WasmEdge_ImportObjectCreate()`. The `Params` is the input"]
    #[doc = " parameters array with length guaranteed to be the same as the parameter"]
    #[doc = " types in the `Type`, and the `ParamLen` is the length of the array. The"]
    #[doc = " `Returns` is the output results array with length guaranteed to be the same"]
    #[doc = " as the result types in the `Type`, and the `ReturnLen` is the length of the"]
    #[doc = " array. The return value is `WasmEdge_Result` for the execution status."]
    #[doc = " \\param Binding the `this` pointer of the host function target or the"]
    #[doc = " function indexing maintained by the caller which can specify the host"]
    #[doc = " function. When invoking the host function, this pointer will be the first"]
    #[doc = " argument of the wrapper function."]
    #[doc = " \\param Cost the function cost in statistics. Pass 0 if the calculation is"]
    #[doc = " not needed."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_HostFunctionCreateBinding(
        Type: *const WasmEdge_FunctionTypeContext,
        WrapFunc: WasmEdge_WrapFunc_t,
        Binding: *mut ::std::os::raw::c_void,
        Cost: u64,
    ) -> *mut WasmEdge_HostFunctionContext;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_HostFunctionContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_HostFunctionContext to delete."]
    pub fn WasmEdge_HostFunctionDelete(Cxt: *mut WasmEdge_HostFunctionContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_TableInstanceContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_TableInstanceDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\param RefType the reference type of the table instance context."]
    #[doc = " \\param Limit the limit struct to initialize the table instance context."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_TableInstanceCreate(
        RefType: WasmEdge_RefType,
        Limit: WasmEdge_Limit,
    ) -> *mut WasmEdge_TableInstanceContext;
}
extern "C" {
    #[doc = " Get the reference type from a table instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the reference type of the table instance."]
    pub fn WasmEdge_TableInstanceGetRefType(
        Cxt: *const WasmEdge_TableInstanceContext,
    ) -> WasmEdge_RefType;
}
extern "C" {
    #[doc = " Get the reference value in a table instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext."]
    #[doc = " \\param [out] Data the result reference value."]
    #[doc = " \\param Offset the reference value offset (index) in the table instance."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_TableInstanceGetData(
        Cxt: *const WasmEdge_TableInstanceContext,
        Data: *mut WasmEdge_Value,
        Offset: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Set the reference value into a table instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext."]
    #[doc = " \\param Data the reference value to set into the table instance."]
    #[doc = " \\param Offset the reference value offset (index) in the table instance."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_TableInstanceSetData(
        Cxt: *mut WasmEdge_TableInstanceContext,
        Data: WasmEdge_Value,
        Offset: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the size of a table instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the size of the table instance."]
    pub fn WasmEdge_TableInstanceGetSize(Cxt: *const WasmEdge_TableInstanceContext) -> u32;
}
extern "C" {
    #[doc = " Grow a table instance with a size."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext."]
    #[doc = " \\param Size the count of reference values to grow in the table instance."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_TableInstanceGrow(
        Cxt: *mut WasmEdge_TableInstanceContext,
        Size: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_TableInstanceContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_TableInstanceContext to delete."]
    pub fn WasmEdge_TableInstanceDelete(Cxt: *mut WasmEdge_TableInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_MemoryInstanceContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_MemoryInstanceDelete`"]
    #[doc = " to free it."]
    #[doc = ""]
    #[doc = " \\param Limit the limit struct to initialize the memory instance context."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_MemoryInstanceCreate(
        Limit: WasmEdge_Limit,
    ) -> *mut WasmEdge_MemoryInstanceContext;
}
extern "C" {
    #[doc = " Copy the data to the output buffer from a memory instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = " \\param [out] Data the result data buffer of copying destination."]
    #[doc = " \\param Offset the data start offset in the memory instance."]
    #[doc = " \\param Length the requested data length. If the `Offset + Length` is larger"]
    #[doc = " than the data size in the memory instance, this function will failed."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_MemoryInstanceGetData(
        Cxt: *const WasmEdge_MemoryInstanceContext,
        Data: *mut u8,
        Offset: u32,
        Length: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Copy the data into a memory instance from the input buffer."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = " \\param Data the data buffer to copy."]
    #[doc = " \\param Offset the data start offset in the memory instance."]
    #[doc = " \\param Length the data buffer length. If the `Offset + Length` is larger"]
    #[doc = " than the data size in the memory instance, this function will failed."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_MemoryInstanceSetData(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Data: *mut u8,
        Offset: u32,
        Length: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the data pointer in a memory instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = " \\param Offset the data start offset in the memory instance."]
    #[doc = " \\param Length the requested data length. If the `Offset + Length` is larger"]
    #[doc = " than the data size in the memory instance, this function will return NULL."]
    #[doc = ""]
    #[doc = " \\returns the pointer to data with the start offset. NULL if failed."]
    pub fn WasmEdge_MemoryInstanceGetPointer(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Offset: u32,
        Length: u32,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get the const data pointer in a const memory instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = " \\param Offset the data start offset in the memory instance."]
    #[doc = " \\param Length the requested data length. If the `Offset + Length` is larger"]
    #[doc = " than the data size in the memory instance, this function will return NULL."]
    #[doc = ""]
    #[doc = " \\returns the pointer to data with the start offset. NULL if failed."]
    pub fn WasmEdge_MemoryInstanceGetPointerConst(
        Cxt: *const WasmEdge_MemoryInstanceContext,
        Offset: u32,
        Length: u32,
    ) -> *const u8;
}
extern "C" {
    #[doc = " Get the current page size (64 KiB of each page) of a memory instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the page size of the memory instance."]
    pub fn WasmEdge_MemoryInstanceGetPageSize(Cxt: *const WasmEdge_MemoryInstanceContext) -> u32;
}
extern "C" {
    #[doc = " Grow a memory instance with a page size."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext."]
    #[doc = " \\param Page the page count to grow in the memory instance."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_MemoryInstanceGrowPage(
        Cxt: *mut WasmEdge_MemoryInstanceContext,
        Page: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_MemoryInstanceContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_MemoryInstanceContext to delete."]
    pub fn WasmEdge_MemoryInstanceDelete(Cxt: *mut WasmEdge_MemoryInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_GlobalInstanceContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_GlobalInstanceDelete`"]
    #[doc = " to free it."]
    #[doc = ""]
    #[doc = " \\param Value the initial value with its value type of the global instance."]
    #[doc = " \\param Mut the mutation of the global instance."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_GlobalInstanceCreate(
        Value: WasmEdge_Value,
        Mut: WasmEdge_Mutability,
    ) -> *mut WasmEdge_GlobalInstanceContext;
}
extern "C" {
    #[doc = " Get the value type from a global instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_GlobalInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the value type of the global instance."]
    pub fn WasmEdge_GlobalInstanceGetValType(
        Cxt: *const WasmEdge_GlobalInstanceContext,
    ) -> WasmEdge_ValType;
}
extern "C" {
    #[doc = " Get the mutability from a global instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_GlobalInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the mutability of the global instance."]
    pub fn WasmEdge_GlobalInstanceGetMutability(
        Cxt: *const WasmEdge_GlobalInstanceContext,
    ) -> WasmEdge_Mutability;
}
extern "C" {
    #[doc = " Get the value from a global instance."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_GlobalInstanceContext."]
    #[doc = ""]
    #[doc = " \\returns the current value of the global instance."]
    pub fn WasmEdge_GlobalInstanceGetValue(
        Cxt: *const WasmEdge_GlobalInstanceContext,
    ) -> WasmEdge_Value;
}
extern "C" {
    #[doc = " Set the value from a global instance."]
    #[doc = ""]
    #[doc = " This function will do nothing if the global context is set as the `Const`"]
    #[doc = " mutation or the value type not matched."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_GlobalInstanceContext."]
    #[doc = " \\param Value the value to set into the global context."]
    pub fn WasmEdge_GlobalInstanceSetValue(
        Cxt: *mut WasmEdge_GlobalInstanceContext,
        Value: WasmEdge_Value,
    );
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_GlobalInstanceContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_GlobalInstanceContext to delete."]
    pub fn WasmEdge_GlobalInstanceDelete(Cxt: *mut WasmEdge_GlobalInstanceContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_ImportObjectDelete` to"]
    #[doc = " free it."]
    #[doc = ""]
    #[doc = " \\param ModuleName the module name WasmEdge_String of this host module to"]
    #[doc = " import."]
    #[doc = " \\param Data the additional object, such as the pointer to a data structure,"]
    #[doc = " to pass to the all host functions added into this import object. The caller"]
    #[doc = " should guarantee the life cycle of the object. NULL if the additional data"]
    #[doc = " object is not needed."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ImportObjectCreate(
        ModuleName: WasmEdge_String,
        Data: *mut ::std::os::raw::c_void,
    ) -> *mut WasmEdge_ImportObjectContext;
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ImportObjectContext for the WASI specification."]
    #[doc = ""]
    #[doc = " This function will create a WASI host module that contains the WASI host"]
    #[doc = " functions and initialize it. The caller owns the object and should call"]
    #[doc = " `WasmEdge_ImportObjectDelete` to free it."]
    #[doc = ""]
    #[doc = " \\param Args the command line arguments. The first argument suggests being"]
    #[doc = " the program name. NULL if the length is 0."]
    #[doc = " \\param ArgLen the length of the command line arguments."]
    #[doc = " \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the"]
    #[doc = " length is 0."]
    #[doc = " \\param EnvLen the length of the environment variables."]
    #[doc = " \\param Dirs the directory mappings in the format `PATH1:PATH2`. NULL if the"]
    #[doc = " length is 0."]
    #[doc = " \\param DirLen the length of the directory mappings."]
    #[doc = " \\param Preopens the directory paths to preopen. NULL if the length is 0."]
    #[doc = " \\param PreopenLen the length of the directory paths to preopen."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ImportObjectCreateWASI(
        Args: *const *const ::std::os::raw::c_char,
        ArgLen: u32,
        Envs: *const *const ::std::os::raw::c_char,
        EnvLen: u32,
        Dirs: *const *const ::std::os::raw::c_char,
        DirLen: u32,
        Preopens: *const *const ::std::os::raw::c_char,
        PreopenLen: u32,
    ) -> *mut WasmEdge_ImportObjectContext;
}
extern "C" {
    #[doc = " Initialize the WasmEdge_ImportObjectContext for the WASI specification."]
    #[doc = ""]
    #[doc = " This function will initialize the WASI host module with the parameters."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext of WASI import object."]
    #[doc = " \\param Args the command line arguments. The first argument suggests being"]
    #[doc = " the program name. NULL if the length is 0."]
    #[doc = " \\param ArgLen the length of the command line arguments."]
    #[doc = " \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the"]
    #[doc = " length is 0."]
    #[doc = " \\param EnvLen the length of the environment variables."]
    #[doc = " \\param Dirs the directory mappings in the format `PATH1:PATH2`. NULL if the"]
    #[doc = " length is 0."]
    #[doc = " \\param DirLen the length of the directory mappings."]
    #[doc = " \\param Preopens the directory paths to preopen. NULL if the length is 0."]
    #[doc = " \\param PreopenLen the length of the directory paths to preopen."]
    pub fn WasmEdge_ImportObjectInitWASI(
        Cxt: *mut WasmEdge_ImportObjectContext,
        Args: *const *const ::std::os::raw::c_char,
        ArgLen: u32,
        Envs: *const *const ::std::os::raw::c_char,
        EnvLen: u32,
        Dirs: *const *const ::std::os::raw::c_char,
        DirLen: u32,
        Preopens: *const *const ::std::os::raw::c_char,
        PreopenLen: u32,
    );
}
extern "C" {
    #[doc = " Creation of the WasmEdge_ImportObjectContext for the wasmedge_process"]
    #[doc = " specification."]
    #[doc = ""]
    #[doc = " This function will create a wasmedge_process host module that contains the"]
    #[doc = " wasmedge_process host functions and initialize it. The caller owns the"]
    #[doc = " object and should call `WasmEdge_ImportObjectDelete` to free it."]
    #[doc = ""]
    #[doc = " \\param AllowedCmds the allowed commands white list. NULL if the length is 0."]
    #[doc = " \\param CmdsLen the length of the allowed commands white list."]
    #[doc = " \\param AllowAll the boolean value to allow all commands. `false` is"]
    #[doc = " suggested. If this value is `true`, the allowed commands white list will not"]
    #[doc = " be recorded and all commands can be executed by wasmedge_process."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_ImportObjectCreateWasmEdgeProcess(
        AllowedCmds: *const *const ::std::os::raw::c_char,
        CmdsLen: u32,
        AllowAll: bool,
    ) -> *mut WasmEdge_ImportObjectContext;
}
extern "C" {
    #[doc = " Initialize the WasmEdge_ImportObjectContext for the wasmedge_process"]
    #[doc = " specification."]
    #[doc = ""]
    #[doc = " This function will initialize the wasmedge_process host module with the"]
    #[doc = " parameters."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext of wasmedge_process import"]
    #[doc = " object."]
    #[doc = " \\param AllowedCmds the allowed commands white list. NULL if the"]
    #[doc = " length is 0."]
    #[doc = " \\param CmdsLen the length of the allowed commands white list."]
    #[doc = " \\param AllowAll the boolean value to allow all commands. `false` is"]
    #[doc = " suggested. If this value is `true`, the allowed commands white list will not"]
    #[doc = " be recorded and all commands can be executed by wasmedge_process."]
    pub fn WasmEdge_ImportObjectInitWasmEdgeProcess(
        Cxt: *mut WasmEdge_ImportObjectContext,
        AllowedCmds: *const *const ::std::os::raw::c_char,
        CmdsLen: u32,
        AllowAll: bool,
    );
}
extern "C" {
    #[doc = " Add a host function context into a WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " Move the host function context into the import object. The caller should"]
    #[doc = " __NOT__ access or delete the host function context after calling this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext to add the host function."]
    #[doc = " \\param Name the host function name WasmEdge_String."]
    #[doc = " \\param HostFuncCxt the WasmEdge_HostFunctionContext to add."]
    pub fn WasmEdge_ImportObjectAddHostFunction(
        Cxt: *mut WasmEdge_ImportObjectContext,
        Name: WasmEdge_String,
        HostFuncCxt: *mut WasmEdge_HostFunctionContext,
    );
}
extern "C" {
    #[doc = " Add a table instance context into a WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " Move the table instance context into the import object. The caller should"]
    #[doc = " __NOT__ access or delete the table instance context after calling this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext to add the table instance."]
    #[doc = " \\param Name the export table name WasmEdge_String."]
    #[doc = " \\param TableCxt the WasmEdge_TableInstanceContext to add."]
    pub fn WasmEdge_ImportObjectAddTable(
        Cxt: *mut WasmEdge_ImportObjectContext,
        Name: WasmEdge_String,
        TableCxt: *mut WasmEdge_TableInstanceContext,
    );
}
extern "C" {
    #[doc = " Add a memory instance context into a WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " Move the memory instance context into the import object. The caller should"]
    #[doc = " __NOT__ access or delete the memory instance context after calling this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext to add the memory instance."]
    #[doc = " \\param Name the export memory name WasmEdge_String."]
    #[doc = " \\param MemoryCxt the WasmEdge_MemoryInstanceContext to add."]
    pub fn WasmEdge_ImportObjectAddMemory(
        Cxt: *mut WasmEdge_ImportObjectContext,
        Name: WasmEdge_String,
        MemoryCxt: *mut WasmEdge_MemoryInstanceContext,
    );
}
extern "C" {
    #[doc = " Add a global instance context into a WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " Move the global instance context into the import object. The caller should"]
    #[doc = " __NOT__ access or delete the global instance context after calling this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext to add the global instance."]
    #[doc = " \\param Name the export global name WasmEdge_String."]
    #[doc = " \\param GlobalCxt the WasmEdge_GlobalInstanceContext to add."]
    pub fn WasmEdge_ImportObjectAddGlobal(
        Cxt: *mut WasmEdge_ImportObjectContext,
        Name: WasmEdge_String,
        GlobalCxt: *mut WasmEdge_GlobalInstanceContext,
    );
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_ImportObjectContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_ImportObjectContext to delete."]
    pub fn WasmEdge_ImportObjectDelete(Cxt: *mut WasmEdge_ImportObjectContext);
}
extern "C" {
    #[doc = " Creation of the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " The caller owns the object and should call `WasmEdge_VMDelete` to free it."]
    #[doc = ""]
    #[doc = " \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of VM."]
    #[doc = " NULL for the default configuration."]
    #[doc = " \\param StoreCxt the WasmEdge_StoreContext as the external WASM store of VM."]
    #[doc = " The instantiation and execution will refer to this store context, and the"]
    #[doc = " life cycle should be ensured until the VM context is deleted. NULL for the"]
    #[doc = " default store owned by `WasmEdge_VMContext`."]
    #[doc = ""]
    #[doc = " \\returns pointer to context, NULL if failed."]
    pub fn WasmEdge_VMCreate(
        ConfCxt: *const WasmEdge_ConfigureContext,
        StoreCxt: *mut WasmEdge_StoreContext,
    ) -> *mut WasmEdge_VMContext;
}
extern "C" {
    #[doc = " Register and instantiate WASM into the store in VM from a WASM file."]
    #[doc = ""]
    #[doc = " Load a WASM file from the path, and register all exported instances and"]
    #[doc = " instantiate them into the store in VM with their exported name and module"]
    #[doc = " name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext which contains the store."]
    #[doc = " \\param ModuleName the WasmEdge_String of module name for all exported"]
    #[doc = " instances."]
    #[doc = " \\param Path the NULL-terminated C string of the WASM file path."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRegisterModuleFromFile(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WASM into the store in VM from a buffer."]
    #[doc = ""]
    #[doc = " Load a WASM module from a buffer, and register all exported instances and"]
    #[doc = " instantiate them into the store in VM with their exported name and module"]
    #[doc = " name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext which contains the store."]
    #[doc = " \\param ModuleName the WasmEdge_String of module name for all exported"]
    #[doc = " instances."]
    #[doc = " \\param Buf the buffer of WASM binary."]
    #[doc = " \\param BufLen the length of the buffer."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRegisterModuleFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WasmEdge import object into the store in VM."]
    #[doc = ""]
    #[doc = " Instantiate the instances in WasmEdge import object context and register"]
    #[doc = " them into the store in VM with their exported name and the host module name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext which contains the store."]
    #[doc = " \\param ImportCxt the WasmEdge_ImportObjectContext to register."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRegisterModuleFromImport(
        Cxt: *mut WasmEdge_VMContext,
        ImportCxt: *const WasmEdge_ImportObjectContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Register and instantiate WASM into the store in VM from a WasmEdge AST"]
    #[doc = " Module."]
    #[doc = ""]
    #[doc = " Load from the WasmEdge AST Module, and register all exported instances and"]
    #[doc = " instantiate them into the store in VM with their exported name and module"]
    #[doc = " name."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext which contains the store."]
    #[doc = " \\param ModuleName the WasmEdge_String of module name for all exported"]
    #[doc = " instances."]
    #[doc = " \\param ASTCxt the WasmEdge AST Module context generated by loader or"]
    #[doc = " compiler."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRegisterModuleFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WASM file and invoke a function by name."]
    #[doc = ""]
    #[doc = " This is the function to invoke a WASM function rapidly."]
    #[doc = " Load and instantiate the WASM module from the file path, and then invoke a"]
    #[doc = " function by name and parameters. If the `Returns` buffer length is smaller"]
    #[doc = " than the arity of the function, the overflowed return values will be"]
    #[doc = " discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param Path the NULL-terminated C string of the WASM file path."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRunWasmFromFile(
        Cxt: *mut WasmEdge_VMContext,
        Path: *const ::std::os::raw::c_char,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a buffer and invoke a function by name."]
    #[doc = ""]
    #[doc = " This is the function to invoke a WASM function rapidly."]
    #[doc = " Load and instantiate the WASM module from a buffer, and then invoke a"]
    #[doc = " function by name and parameters. If the `Returns` buffer length is smaller"]
    #[doc = " than the arity of the function, the overflowed return values will be"]
    #[doc = " discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param Buf the buffer of WASM binary."]
    #[doc = " \\param BufLen the length of the buffer."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRunWasmFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        Buf: *const u8,
        BufLen: u32,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the WASM module from a WasmEdge AST Module and invoke a function"]
    #[doc = " by name."]
    #[doc = ""]
    #[doc = " This is the function to invoke a WASM function rapidly."]
    #[doc = " Load and instantiate the WASM module from the WasmEdge AST Module, and then"]
    #[doc = " invoke the function by name and parameters. If the `Returns` buffer length"]
    #[doc = " is smaller than the arity of the function, the overflowed return values will"]
    #[doc = " be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param ASTCxt the WasmEdge AST Module context generated by loader or"]
    #[doc = " compiler."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMRunWasmFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load the WASM module from a WASM file."]
    #[doc = ""]
    #[doc = " This is the first step to invoke a WASM function step by step."]
    #[doc = " Load and parse the WASM module from the file path. You can then call"]
    #[doc = " `WasmEdge_VMValidate` for the next step."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param Path the NULL-terminated C string of the WASM file path."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMLoadWasmFromFile(
        Cxt: *mut WasmEdge_VMContext,
        Path: *const ::std::os::raw::c_char,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load the WASM module from a buffer."]
    #[doc = ""]
    #[doc = " This is the first step to invoke a WASM function step by step."]
    #[doc = " Load and parse the WASM module from a buffer. You can then call"]
    #[doc = " `WasmEdge_VMValidate` for the next step."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param Buf the buffer of WASM binary."]
    #[doc = " \\param BufLen the length of the buffer."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMLoadWasmFromBuffer(
        Cxt: *mut WasmEdge_VMContext,
        Buf: *const u8,
        BufLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Load the WASM module from loaded WasmEdge AST Module."]
    #[doc = ""]
    #[doc = " This is the first step to invoke a WASM function step by step."]
    #[doc = " Copy the loaded WasmEdge AST Module context into VM. The VM context has no"]
    #[doc = " dependency on the input AST Module context. You can then call"]
    #[doc = " `WasmEdge_VMValidate` for the next step."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param ASTCxt the WasmEdge AST Module context generated by loader or"]
    #[doc = " compiler."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMLoadWasmFromASTModule(
        Cxt: *mut WasmEdge_VMContext,
        ASTCxt: *const WasmEdge_ASTModuleContext,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Validate the WASM module loaded into the VM context."]
    #[doc = ""]
    #[doc = " This is the second step to invoke a WASM function step by step."]
    #[doc = " After loading a WASM module into VM context, You can call this function to"]
    #[doc = " validate it. And you can then call `WasmEdge_VMInstantiate` for the next"]
    #[doc = " step. Note that only validated WASM modules can be instantiated in the VM"]
    #[doc = " context."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMValidate(Cxt: *mut WasmEdge_VMContext) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Instantiate the validated WASM module in the VM context."]
    #[doc = ""]
    #[doc = " This is the third step to invoke a WASM function step by step."]
    #[doc = " After validating a WASM module in the VM context, You can call this function"]
    #[doc = " to instantiate it. And you can then call `WasmEdge_VMExecute` for invoking"]
    #[doc = " the exported function in this WASM module."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMInstantiate(Cxt: *mut WasmEdge_VMContext) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by name."]
    #[doc = ""]
    #[doc = " This is the final step to invoke a WASM function step by step."]
    #[doc = " After instantiating a WASM module in the VM context, the WASM module is"]
    #[doc = " registered into the store in the VM context as an anonymous module. Then you"]
    #[doc = " can repeatedly call this function to invoke the exported WASM functions by"]
    #[doc = " their names until the VM context is reset or a new WASM module is registered"]
    #[doc = " or loaded. For calling the functions in registered WASM modules with module"]
    #[doc = " names, please use `WasmEdge_VMExecuteRegistered` instead. If the `Returns`"]
    #[doc = " buffer length is smaller than the arity of the function, the overflowed"]
    #[doc = " return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMExecute(
        Cxt: *mut WasmEdge_VMContext,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Invoke a WASM function by its module name and function name."]
    #[doc = ""]
    #[doc = " After registering a WASM module in the VM context, you can repeatedly call"]
    #[doc = " this function to invoke exported WASM functions by their module names and"]
    #[doc = " function names until the VM context is reset. If the `Returns` buffer length"]
    #[doc = " is smaller than the arity of the function, the overflowed return values will"]
    #[doc = " be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = " \\param Params the WasmEdge_Value buffer with the parameter values."]
    #[doc = " \\param ParamLen the parameter buffer length."]
    #[doc = " \\param [out] Returns the WasmEdge_Value buffer to fill the return values."]
    #[doc = " \\param ReturnLen the return buffer length."]
    #[doc = ""]
    #[doc = " \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error"]
    #[doc = " message."]
    pub fn WasmEdge_VMExecuteRegistered(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
        Params: *const WasmEdge_Value,
        ParamLen: u32,
        Returns: *mut WasmEdge_Value,
        ReturnLen: u32,
    ) -> WasmEdge_Result;
}
extern "C" {
    #[doc = " Get the function type by function name."]
    #[doc = ""]
    #[doc = " After instantiating a WASM module in the VM context, the WASM module is"]
    #[doc = " registered into the store in the VM context as an anonymous module. Then you"]
    #[doc = " can call this function to get the function type by the exported function"]
    #[doc = " name until the VM context is reset or a new WASM module is registered or"]
    #[doc = " loaded. For getting the function type of functions in registered WASM"]
    #[doc = " modules with module names, please use `WasmEdge_VMGetFunctionTypeRegistered`"]
    #[doc = " instead."]
    #[doc = " The caller owns the returned function type context, and should call the"]
    #[doc = " `WasmEdge_FunctionTypeDelete` to delete it."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the function type. NULL if the function not found."]
    pub fn WasmEdge_VMGetFunctionType(
        Cxt: *mut WasmEdge_VMContext,
        FuncName: WasmEdge_String,
    ) -> *mut WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Get the function type by function name."]
    #[doc = ""]
    #[doc = " After registering a WASM module in the VM context, you can call this"]
    #[doc = " function to get the function type by the functions' exported module names"]
    #[doc = " and function names until the VM context is reset."]
    #[doc = " The caller owns the returned function type context, and should call the"]
    #[doc = " `WasmEdge_FunctionTypeDelete` to delete it."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param ModuleName the module name WasmEdge_String."]
    #[doc = " \\param FuncName the function name WasmEdge_String."]
    #[doc = ""]
    #[doc = " \\returns the function type. NULL if the function not found."]
    pub fn WasmEdge_VMGetFunctionTypeRegistered(
        Cxt: *mut WasmEdge_VMContext,
        ModuleName: WasmEdge_String,
        FuncName: WasmEdge_String,
    ) -> *mut WasmEdge_FunctionTypeContext;
}
extern "C" {
    #[doc = " Reset of WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " After calling this function, the statistics, loaded module, and the"]
    #[doc = " instances in the store except registered instances will be cleared."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext to reset."]
    pub fn WasmEdge_VMCleanup(Cxt: *mut WasmEdge_VMContext);
}
extern "C" {
    #[doc = " Get the length of exported function list."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " \\returns length of exported function list."]
    pub fn WasmEdge_VMGetFunctionListLength(Cxt: *mut WasmEdge_VMContext) -> u32;
}
extern "C" {
    #[doc = " Get the exported function list."]
    #[doc = ""]
    #[doc = " The returned function names are created and stored in `Names` array, and"]
    #[doc = " the caller should call `WasmEdge_StringDelete` to delete them. The function"]
    #[doc = " type contexts of the corresponding function names are allocated and stored"]
    #[doc = " in `FuncTypes` array, and the caller should call"]
    #[doc = " `WasmEdge_FunctionTypeDelete` to delete them. If the `Names` and `FuncTypes`"]
    #[doc = " buffer lengths are smaller than the result of the exported function list"]
    #[doc = " size, the overflowed return values will be discarded."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param [out] Names the output names WasmEdge_String buffer of exported"]
    #[doc = " functions. Can be NULL if names are not needed."]
    #[doc = " \\param [out] FuncTypes the function type contexts buffer. Can be NULL if"]
    #[doc = " function types are not needed."]
    #[doc = " \\param Len the buffer length."]
    #[doc = ""]
    #[doc = " \\returns actual exported function list size."]
    pub fn WasmEdge_VMGetFunctionList(
        Cxt: *mut WasmEdge_VMContext,
        Names: *mut WasmEdge_String,
        FuncTypes: *mut *mut WasmEdge_FunctionTypeContext,
        Len: u32,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the import object corresponding to the WasmEdge_HostRegistration"]
    #[doc = " settings."]
    #[doc = ""]
    #[doc = " When creating the VM context with configuration, the host module will be"]
    #[doc = " registered according to the `WasmEdge_HostRegistration` settings added into"]
    #[doc = " the `WasmEdge_ConfigureContext`. You can call this function to get the"]
    #[doc = " `WasmEdge_ImportObjectContext` corresponding to the settings. The import"]
    #[doc = " object context links to the context owned by the VM context. The caller"]
    #[doc = " should __NOT__ call the `WasmEdge_ImportObjectDelete`."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();"]
    #[doc = " WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);"]
    #[doc = " WasmEdge_ConfigureAddHostRegistration("]
    #[doc = "     Conf, WasmEdge_HostRegistration_WasmEdge_Process);"]
    #[doc = " WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);"]
    #[doc = " WasmEdge_ImportObjectContext *WasiMod ="]
    #[doc = "     WasmEdge_VMGetImportModuleContext(VM, WasmEdge_HostRegistration_Wasi);"]
    #[doc = " WasmEdge_ImportObjectContext *ProcessMod ="]
    #[doc = "     WasmEdge_VMGetImportModuleContext("]
    #[doc = "         VM, WasmEdge_HostRegistration_WasmEdge_Process);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = " \\param Reg the host registration value to get the import module."]
    #[doc = ""]
    #[doc = " \\returns pointer to the import module context. NULL if not found."]
    pub fn WasmEdge_VMGetImportModuleContext(
        Cxt: *mut WasmEdge_VMContext,
        Reg: WasmEdge_HostRegistration,
    ) -> *mut WasmEdge_ImportObjectContext;
}
extern "C" {
    #[doc = " Get the store context used in the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " The store context links to the store in the VM context and owned by the VM"]
    #[doc = " context. The caller should __NOT__ call the `WasmEdge_StoreDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " \\returns pointer to the store context."]
    pub fn WasmEdge_VMGetStoreContext(Cxt: *mut WasmEdge_VMContext) -> *mut WasmEdge_StoreContext;
}
extern "C" {
    #[doc = " Get the statistics context used in the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " The statistics context links to the statistics in the VM context and owned"]
    #[doc = " by the VM context. The caller should __NOT__ call the"]
    #[doc = " `WasmEdge_StatisticsDelete`."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " \\returns pointer to the statistics context."]
    pub fn WasmEdge_VMGetStatisticsContext(
        Cxt: *mut WasmEdge_VMContext,
    ) -> *mut WasmEdge_StatisticsContext;
}
extern "C" {
    #[doc = " Deletion of the WasmEdge_VMContext."]
    #[doc = ""]
    #[doc = " After calling this function, the context will be freed and should __NOT__ be"]
    #[doc = " used."]
    #[doc = ""]
    #[doc = " \\param Cxt the WasmEdge_VMContext to delete."]
    pub fn WasmEdge_VMDelete(Cxt: *mut WasmEdge_VMContext);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
