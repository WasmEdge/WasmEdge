<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/__w/WasmEdge/WasmEdge/bindings/rust/./target/debug/build/wasmedge-sys-2874c6a5be943850/out/wasmedge.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>wasmedge.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-93196c7a1c3542a8.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../../../../../../../../../../static.files/light-4743e13df3dfe8c4.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/dark-0e1b889528bd466b.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/ayu-65289d5d067c7c66.css"><script id="default-settings" ></script><script src="../../../../../../../../../../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../../../../../../../../../../static.files/source-script-ea63cb6500f71309.js"></script><script defer src="../../../../../../../../../../../../source-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-3367e395607fafc1.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/cncf/artwork/49169bdbc88a7ce3c4a722c641cc2d548bd5c340/projects/wasm-edge-runtime/icon/color/wasm-edge-runtime-icon-color.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../../../../../../../../../../../wasmedge_sys/index.html">
                        <img src="https://github.com/cncf/artwork/blob/master/projects/wasm-edge-runtime/icon/color/wasm-edge-runtime-icon-color.png?raw=true" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../../../../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
</pre><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.61.0 */

</span><span class="kw">pub const </span>true_ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>false_ : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__bool_true_false_are_defined : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_STDINT_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_FEATURES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_DEFAULT_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__GLIBC_USE_ISOC2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__USE_ISOC11 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ISOC99 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ISOC95 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX_IMPLICITLY : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_POSIX_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_POSIX_C_SOURCE : u32 = <span class="number">200809 </span>; <span class="kw">pub const </span>__USE_POSIX : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX2 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX199309 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX199506 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_XOPEN2K : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_XOPEN2K8 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_ATFILE_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_MISC : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ATFILE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_FORTIFY_LEVEL : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_DEPRECATED_GETS : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_DEPRECATED_SCANF : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>_STDC_PREDEF_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_IEC_559__ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_IEC_559_COMPLEX__ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_ISO_10646__ : u32 = <span class="number">201706 </span>; <span class="kw">pub const </span>__GNU_LIBRARY__ : u32 = <span class="number">6 </span>; <span class="kw">pub const </span>__GLIBC__ : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>__GLIBC_MINOR__ : u32 = <span class="number">31 </span>; <span class="kw">pub const </span>_SYS_CDEFS_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__glibc_c99_flexarr_available : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__WORDSIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>__WORDSIZE_TIME64_COMPAT32 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__SYSCALL_WORDSIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>__LONG_DOUBLE_USES_FLOAT128 : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__HAVE_GENERIC_SELECTION : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__GLIBC_USE_LIB_EXT2 : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_BFP_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_BFP_EXT_C2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_TYPES_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>_BITS_TYPES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__TIMESIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>_BITS_TYPESIZES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__OFF_T_MATCHES_OFF64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__INO_T_MATCHES_INO64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__RLIM_T_MATCHES_RLIM64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STATFS_MATCHES_STATFS64 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__FD_SETSIZE : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>_BITS_TIME64_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_WCHAR_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_STDINT_INTN_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_STDINT_UINTN_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>INT8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT16_MIN : i32 = - <span class="number">32768 </span>; <span class="kw">pub const </span>INT32_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>INT8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT16_MAX : u32 = <span class="number">32767 </span>; <span class="kw">pub const </span>INT32_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>UINT8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT16_MAX : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>UINT32_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>INT_LEAST8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT_LEAST16_MIN : i32 = - <span class="number">32768 </span>; <span class="kw">pub const </span>INT_LEAST32_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>INT_LEAST8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT_LEAST16_MAX : u32 = <span class="number">32767 </span>; <span class="kw">pub const </span>INT_LEAST32_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>UINT_LEAST8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT_LEAST16_MAX : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>UINT_LEAST32_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>INT_FAST8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT_FAST16_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INT_FAST32_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INT_FAST8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT_FAST16_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>INT_FAST32_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>UINT_FAST8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT_FAST16_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>UINT_FAST32_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>INTPTR_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INTPTR_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>UINTPTR_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>PTRDIFF_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>PTRDIFF_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>SIG_ATOMIC_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>SIG_ATOMIC_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>SIZE_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>WINT_MIN : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WINT_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION : &amp; [u8 ; <span class="number">17usize</span>] = <span class="string">b&quot;0.0.0-unreleased\0&quot; </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_MAJOR : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_MINOR : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_PATCH : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_Plugin_CurrentAPIVersion : u32 = <span class="number">2 </span>; <span class="kw">pub type </span>__u_char = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>__u_short = :: std :: os :: raw :: c_ushort ; <span class="kw">pub type </span>__u_int = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__u_long = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__int8_t = :: std :: os :: raw :: c_schar ; <span class="kw">pub type </span>__uint8_t = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>__int16_t = :: std :: os :: raw :: c_short ; <span class="kw">pub type </span>__uint16_t = :: std :: os :: raw :: c_ushort ; <span class="kw">pub type </span>__int32_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__uint32_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__int64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__uint64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__int_least8_t = __int8_t ; <span class="kw">pub type </span>__uint_least8_t = __uint8_t ; <span class="kw">pub type </span>__int_least16_t = __int16_t ; <span class="kw">pub type </span>__uint_least16_t = __uint16_t ; <span class="kw">pub type </span>__int_least32_t = __int32_t ; <span class="kw">pub type </span>__uint_least32_t = __uint32_t ; <span class="kw">pub type </span>__int_least64_t = __int64_t ; <span class="kw">pub type </span>__uint_least64_t = __uint64_t ; <span class="kw">pub type </span>__quad_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__u_quad_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__intmax_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__uintmax_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__dev_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__uid_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__gid_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__ino_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__ino64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__mode_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__nlink_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__off_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__off64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__pid_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__fsid_t { <span class="kw">pub </span>__val : [:: std :: os :: raw :: c_int ; <span class="number">2usize</span>] , } # [test] <span class="kw">fn </span>bindgen_test_layout___fsid_t () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; __fsid_t &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; __fsid_t &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (__fsid_t))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; __fsid_t &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (__fsid_t))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (__fsid_t) , <span class="string">&quot;::&quot; </span>, stringify ! (__val))) ; } <span class="kw">pub type </span>__clock_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__rlim_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__rlim64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__id_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__time_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__useconds_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__suseconds_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__daddr_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__key_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__clockid_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__timer_t = * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; <span class="kw">pub type </span>__blksize_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__blkcnt_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__blkcnt64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__fsblkcnt_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsfilcnt_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsword_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__ssize_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__syscall_slong_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__syscall_ulong_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__loff_t = __off64_t ; <span class="kw">pub type </span>__caddr_t = * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; <span class="kw">pub type </span>__intptr_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__socklen_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__sig_atomic_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>int_least8_t = __int_least8_t ; <span class="kw">pub type </span>int_least16_t = __int_least16_t ; <span class="kw">pub type </span>int_least32_t = __int_least32_t ; <span class="kw">pub type </span>int_least64_t = __int_least64_t ; <span class="kw">pub type </span>uint_least8_t = __uint_least8_t ; <span class="kw">pub type </span>uint_least16_t = __uint_least16_t ; <span class="kw">pub type </span>uint_least32_t = __uint_least32_t ; <span class="kw">pub type </span>uint_least64_t = __uint_least64_t ; <span class="kw">pub type </span>int_fast8_t = :: std :: os :: raw :: c_schar ; <span class="kw">pub type </span>int_fast16_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>int_fast32_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>int_fast64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>uint_fast8_t = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>uint_fast16_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>uint_fast32_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>uint_fast64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>intmax_t = __intmax_t ; <span class="kw">pub type </span>uintmax_t = __uintmax_t ; <span class="kw">pub const </span>WasmEdge_Proposal_ImportExportMutGlobals : WasmEdge_Proposal = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_NonTrapFloatToIntConversions : WasmEdge_Proposal = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_SignExtensionOperators : WasmEdge_Proposal = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_MultiValue : WasmEdge_Proposal = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_BulkMemoryOperations : WasmEdge_Proposal = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ReferenceTypes : WasmEdge_Proposal = <span class="number">5 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_SIMD : WasmEdge_Proposal = <span class="number">6 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_TailCall : WasmEdge_Proposal = <span class="number">7 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_MultiMemories : WasmEdge_Proposal = <span class="number">8 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Annotations : WasmEdge_Proposal = <span class="number">9 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Memory64 : WasmEdge_Proposal = <span class="number">10 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ExceptionHandling : WasmEdge_Proposal = <span class="number">11 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ExtendedConst : WasmEdge_Proposal = <span class="number">12 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Threads : WasmEdge_Proposal = <span class="number">13 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_FunctionReferences : WasmEdge_Proposal = <span class="number">14 </span>; # [doc = <span class="string">&quot; WASM Proposal C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_Proposal = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_HostRegistration_Wasi : WasmEdge_HostRegistration = <span class="number">0 </span>; # [doc = <span class="string">&quot; Host Module Registration C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_HostRegistration = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O0 : WasmEdge_CompilerOptimizationLevel = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O1 : WasmEdge_CompilerOptimizationLevel = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O2 : WasmEdge_CompilerOptimizationLevel = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O3 : WasmEdge_CompilerOptimizationLevel = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_Os : WasmEdge_CompilerOptimizationLevel = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_Oz : WasmEdge_CompilerOptimizationLevel = <span class="number">5 </span>; # [doc = <span class="string">&quot; AOT compiler optimization level C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_CompilerOptimizationLevel = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_CompilerOutputFormat_Native : WasmEdge_CompilerOutputFormat = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOutputFormat_Wasm : WasmEdge_CompilerOutputFormat = <span class="number">1 </span>; # [doc = <span class="string">&quot; AOT compiler output binary format C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_CompilerOutputFormat = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ErrCategory_WASM : WasmEdge_ErrCategory = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ErrCategory_UserLevelError : WasmEdge_ErrCategory = <span class="number">1 </span>; # [doc = <span class="string">&quot; Error category C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ErrCategory = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ErrCode_Success : WasmEdge_ErrCode = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Terminated : WasmEdge_ErrCode = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_RuntimeError : WasmEdge_ErrCode = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_CostLimitExceeded : WasmEdge_ErrCode = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongVMWorkflow : WasmEdge_ErrCode = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_FuncNotFound : WasmEdge_ErrCode = <span class="number">5 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_AOTDisabled : WasmEdge_ErrCode = <span class="number">6 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Interrupted : WasmEdge_ErrCode = <span class="number">7 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_NotValidated : WasmEdge_ErrCode = <span class="number">8 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UserDefError : WasmEdge_ErrCode = <span class="number">9 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalPath : WasmEdge_ErrCode = <span class="number">32 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ReadError : WasmEdge_ErrCode = <span class="number">33 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnexpectedEnd : WasmEdge_ErrCode = <span class="number">34 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedMagic : WasmEdge_ErrCode = <span class="number">35 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedVersion : WasmEdge_ErrCode = <span class="number">36 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedSection : WasmEdge_ErrCode = <span class="number">37 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_SectionSizeMismatch : WasmEdge_ErrCode = <span class="number">38 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_LengthOutOfBounds : WasmEdge_ErrCode = <span class="number">39 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_JunkSection : WasmEdge_ErrCode = <span class="number">40 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleFuncCode : WasmEdge_ErrCode = <span class="number">41 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleDataCount : WasmEdge_ErrCode = <span class="number">42 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DataCountRequired : WasmEdge_ErrCode = <span class="number">43 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedImportKind : WasmEdge_ErrCode = <span class="number">44 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedExportKind : WasmEdge_ErrCode = <span class="number">45 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ExpectedZeroByte : WasmEdge_ErrCode = <span class="number">46 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMut : WasmEdge_ErrCode = <span class="number">47 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TooManyLocals : WasmEdge_ErrCode = <span class="number">48 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedValType : WasmEdge_ErrCode = <span class="number">49 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedElemType : WasmEdge_ErrCode = <span class="number">50 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedRefType : WasmEdge_ErrCode = <span class="number">51 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedUTF8 : WasmEdge_ErrCode = <span class="number">52 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerTooLarge : WasmEdge_ErrCode = <span class="number">53 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerTooLong : WasmEdge_ErrCode = <span class="number">54 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalOpCode : WasmEdge_ErrCode = <span class="number">55 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ENDCodeExpected : WasmEdge_ErrCode = <span class="number">56 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalGrammar : WasmEdge_ErrCode = <span class="number">57 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_SharedMemoryNoMax : WasmEdge_ErrCode = <span class="number">58 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntrinsicsTableNotFound : WasmEdge_ErrCode = <span class="number">59 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidAlignment : WasmEdge_ErrCode = <span class="number">64 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TypeCheckFailed : WasmEdge_ErrCode = <span class="number">65 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLabelIdx : WasmEdge_ErrCode = <span class="number">66 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLocalIdx : WasmEdge_ErrCode = <span class="number">67 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidFuncTypeIdx : WasmEdge_ErrCode = <span class="number">68 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidFuncIdx : WasmEdge_ErrCode = <span class="number">69 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidTableIdx : WasmEdge_ErrCode = <span class="number">70 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMemoryIdx : WasmEdge_ErrCode = <span class="number">71 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidGlobalIdx : WasmEdge_ErrCode = <span class="number">72 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidElemIdx : WasmEdge_ErrCode = <span class="number">73 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidDataIdx : WasmEdge_ErrCode = <span class="number">74 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidRefIdx : WasmEdge_ErrCode = <span class="number">75 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ConstExprRequired : WasmEdge_ErrCode = <span class="number">76 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DupExportName : WasmEdge_ErrCode = <span class="number">77 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ImmutableGlobal : WasmEdge_ErrCode = <span class="number">78 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidResultArity : WasmEdge_ErrCode = <span class="number">79 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MultiTables : WasmEdge_ErrCode = <span class="number">80 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MultiMemories : WasmEdge_ErrCode = <span class="number">81 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLimit : WasmEdge_ErrCode = <span class="number">82 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMemPages : WasmEdge_ErrCode = <span class="number">83 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidStartFunc : WasmEdge_ErrCode = <span class="number">84 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLaneIdx : WasmEdge_ErrCode = <span class="number">85 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ModuleNameConflict : WasmEdge_ErrCode = <span class="number">96 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleImportType : WasmEdge_ErrCode = <span class="number">97 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnknownImport : WasmEdge_ErrCode = <span class="number">98 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DataSegDoesNotFit : WasmEdge_ErrCode = <span class="number">99 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ElemSegDoesNotFit : WasmEdge_ErrCode = <span class="number">100 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongInstanceAddress : WasmEdge_ErrCode = <span class="number">128 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongInstanceIndex : WasmEdge_ErrCode = <span class="number">129 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InstrTypeMismatch : WasmEdge_ErrCode = <span class="number">130 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_FuncSigMismatch : WasmEdge_ErrCode = <span class="number">131 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DivideByZero : WasmEdge_ErrCode = <span class="number">132 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerOverflow : WasmEdge_ErrCode = <span class="number">133 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidConvToInt : WasmEdge_ErrCode = <span class="number">134 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TableOutOfBounds : WasmEdge_ErrCode = <span class="number">135 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MemoryOutOfBounds : WasmEdge_ErrCode = <span class="number">136 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Unreachable : WasmEdge_ErrCode = <span class="number">137 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UninitializedElement : WasmEdge_ErrCode = <span class="number">138 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UndefinedElement : WasmEdge_ErrCode = <span class="number">139 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IndirectCallTypeMismatch : WasmEdge_ErrCode = <span class="number">140 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_HostFuncError : WasmEdge_ErrCode = <span class="number">141 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_RefTypeMismatch : WasmEdge_ErrCode = <span class="number">142 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnalignedAtomicAccess : WasmEdge_ErrCode = <span class="number">143 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ExpectSharedMemory : WasmEdge_ErrCode = <span class="number">144 </span>; # [doc = <span class="string">&quot; Error code C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ErrCode = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ValType_I32 : WasmEdge_ValType = <span class="number">127 </span>; <span class="kw">pub const </span>WasmEdge_ValType_I64 : WasmEdge_ValType = <span class="number">126 </span>; <span class="kw">pub const </span>WasmEdge_ValType_F32 : WasmEdge_ValType = <span class="number">125 </span>; <span class="kw">pub const </span>WasmEdge_ValType_F64 : WasmEdge_ValType = <span class="number">124 </span>; <span class="kw">pub const </span>WasmEdge_ValType_V128 : WasmEdge_ValType = <span class="number">123 </span>; <span class="kw">pub const </span>WasmEdge_ValType_FuncRef : WasmEdge_ValType = <span class="number">112 </span>; <span class="kw">pub const </span>WasmEdge_ValType_ExternRef : WasmEdge_ValType = <span class="number">111 </span>; # [doc = <span class="string">&quot; WASM Value type C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ValType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_NumType_I32 : WasmEdge_NumType = <span class="number">127 </span>; <span class="kw">pub const </span>WasmEdge_NumType_I64 : WasmEdge_NumType = <span class="number">126 </span>; <span class="kw">pub const </span>WasmEdge_NumType_F32 : WasmEdge_NumType = <span class="number">125 </span>; <span class="kw">pub const </span>WasmEdge_NumType_F64 : WasmEdge_NumType = <span class="number">124 </span>; <span class="kw">pub const </span>WasmEdge_NumType_V128 : WasmEdge_NumType = <span class="number">123 </span>; # [doc = <span class="string">&quot; WASM Number type C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_NumType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_RefType_FuncRef : WasmEdge_RefType = <span class="number">112 </span>; <span class="kw">pub const </span>WasmEdge_RefType_ExternRef : WasmEdge_RefType = <span class="number">111 </span>; # [doc = <span class="string">&quot; WASM Reference type C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_RefType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_Mutability_Const : WasmEdge_Mutability = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_Mutability_Var : WasmEdge_Mutability = <span class="number">1 </span>; # [doc = <span class="string">&quot; WASM Mutability C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_Mutability = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ExternalType_Function : WasmEdge_ExternalType = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Table : WasmEdge_ExternalType = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Memory : WasmEdge_ExternalType = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Global : WasmEdge_ExternalType = <span class="number">3 </span>; # [doc = <span class="string">&quot; WASM External type C enumeration.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ExternalType = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>uint128_t = u128 ; <span class="kw">pub type </span>int128_t = i128 ; # [doc = <span class="string">&quot; WasmEdge WASM value struct.&quot;</span>] # [repr (C)] # [repr (align (<span class="number">16</span>))] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Value { <span class="kw">pub </span>Value : uint128_t , <span class="kw">pub </span>Type : WasmEdge_ValType , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Value () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Value &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Value &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Value))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Value &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Value) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Value) , <span class="string">&quot;::&quot; </span>, stringify ! (Value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Type) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Value) , <span class="string">&quot;::&quot; </span>, stringify ! (Type))) ; } # [doc = <span class="string">&quot; WasmEdge string struct.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_String { <span class="kw">pub </span>Length : u32 , <span class="kw">pub </span>Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_String () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_String &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_String &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_String))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_String &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_String))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Length) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_String) , <span class="string">&quot;::&quot; </span>, stringify ! (Length))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Buf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_String) , <span class="string">&quot;::&quot; </span>, stringify ! (Buf))) ; } # [doc = <span class="string">&quot; WasmEdge result struct.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Result { <span class="kw">pub </span>Code : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Result () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Result &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Result &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Result))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Result &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Result))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Code) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Result) , <span class="string">&quot;::&quot; </span>, stringify ! (Code))) ; } # [doc = <span class="string">&quot; Struct of WASM limit.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Limit { # [doc = <span class="string">&quot; Boolean to describe has max value or not.&quot;</span>] <span class="kw">pub </span>HasMax : bool , # [doc = <span class="string">&quot; Boolean to describe is shared memory or not.&quot;</span>] <span class="kw">pub </span>Shared : bool , # [doc = <span class="string">&quot; Minimum value.&quot;</span>] <span class="kw">pub </span>Min : u32 , # [doc = <span class="string">&quot; Maximum value. Will be ignored if the `HasMax` is false.&quot;</span>] <span class="kw">pub </span>Max : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Limit () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Limit &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Limit &gt; () , <span class="number">12usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Limit))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Limit &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Limit))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . HasMax) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (HasMax))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Shared) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">1usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Shared))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Min) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Min))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Max) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Max))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ConfigureContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_StatisticsContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ASTModuleContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_FunctionTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_MemoryTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_TableTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_GlobalTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ImportTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ExportTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_CompilerContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_LoaderContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ValidatorContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ExecutorContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_StoreContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ModuleInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_FunctionInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_TableInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_MemoryInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_GlobalInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_CallingFrameContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Async { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_VMContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginContext { _unused : [u8 ; <span class="number">0</span>] , } # [doc = <span class="string">&quot; No option value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_None : WasmEdge_ProgramOptionType = <span class="number">0 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Toggle : WasmEdge_ProgramOptionType = <span class="number">1 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int8 : WasmEdge_ProgramOptionType = <span class="number">2 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int16 : WasmEdge_ProgramOptionType = <span class="number">3 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int32 : WasmEdge_ProgramOptionType = <span class="number">4 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int64 : WasmEdge_ProgramOptionType = <span class="number">5 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt8 : WasmEdge_ProgramOptionType = <span class="number">6 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt16 : WasmEdge_ProgramOptionType = <span class="number">7 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt32 : WasmEdge_ProgramOptionType = <span class="number">8 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt64 : WasmEdge_ProgramOptionType = <span class="number">9 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Float : WasmEdge_ProgramOptionType = <span class="number">10 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Double : WasmEdge_ProgramOptionType = <span class="number">11 </span>; # [doc = <span class="string">&quot; WasmEdge_String.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_String : WasmEdge_ProgramOptionType = <span class="number">12 </span>; # [doc = <span class="string">&quot; Type of option value.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ProgramOptionType = :: std :: os :: raw :: c_uint ; # [doc = <span class="string">&quot; Program option for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ProgramOption { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Type : WasmEdge_ProgramOptionType , <span class="kw">pub </span>Storage : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>DefaultValue : * <span class="kw">const </span>:: std :: os :: raw :: c_void , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_ProgramOption () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_ProgramOption &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_ProgramOption &gt; () , <span class="number">40usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_ProgramOption))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_ProgramOption &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_ProgramOption))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Type) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Type))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Storage) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Storage))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . DefaultValue) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (DefaultValue))) ; } # [doc = <span class="string">&quot; Module descriptor for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ModuleDescriptor { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Create : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(arg1 : * <span class="kw">const </span>WasmEdge_ModuleDescriptor) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_ModuleDescriptor () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_ModuleDescriptor &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_ModuleDescriptor &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_ModuleDescriptor &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Create) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Create))) ; } # [doc = <span class="string">&quot; Version data for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginVersionData { <span class="kw">pub </span>Major : u32 , <span class="kw">pub </span>Minor : u32 , <span class="kw">pub </span>Patch : u32 , <span class="kw">pub </span>Build : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_PluginVersionData () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_PluginVersionData &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_PluginVersionData &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_PluginVersionData))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_PluginVersionData &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_PluginVersionData))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Major) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Major))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Minor) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Minor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Patch) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Patch))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Build) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Build))) ; } # [doc = <span class="string">&quot; Plugin descriptor for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginDescriptor { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>APIVersion : u32 , <span class="kw">pub </span>Version : WasmEdge_PluginVersionData , <span class="kw">pub </span>ModuleCount : u32 , <span class="kw">pub </span>ProgramOptionCount : u32 , <span class="kw">pub </span>ModuleDescriptions : * <span class="kw-2">mut </span>WasmEdge_ModuleDescriptor , <span class="kw">pub </span>ProgramOptions : * <span class="kw-2">mut </span>WasmEdge_ProgramOption , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_PluginDescriptor () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_PluginDescriptor &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_PluginDescriptor &gt; () , <span class="number">64usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_PluginDescriptor &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_PluginDescriptor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . APIVersion) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (APIVersion))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Version) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">20usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Version))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ModuleCount) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">36usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ModuleCount))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ProgramOptionCount) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ProgramOptionCount))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ModuleDescriptions) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ModuleDescriptions))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ProgramOptions) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ProgramOptions))) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the version string of the WasmEdge C API.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string must __NOT__ be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns NULL-terminated C string of version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGet () -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the major version value of the WasmEdge C API.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns Value of the major version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetMajor () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the minor version value of the WasmEdge C API.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns Value of the minor version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetMinor () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the patch version value of the WasmEdge C API.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns Value of the patch version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetPatch () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system to filter to error level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogSetErrorLevel () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system to filter to debug level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogSetDebugLevel () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system off.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogOff () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the I32 WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the I32 value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the I32 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenI32 (Val : i32) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the I64 WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the I64 value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the I64 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenI64 (Val : i64) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the F32 WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the F32 value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the F32 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenF32 (Val : f32) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the F64 WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the F64 value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the F64 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenF64 (Val : f64) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the V128 WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the V128 value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the V128 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenV128 (Val : int128_t) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the NULL reference WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The values generated by this function are only meaningful when the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Proposal_BulkMemoryOperations` or the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param T the reference type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the NULL reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenNullRef (T : WasmEdge_RefType) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the function reference WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The values generated by this function are only meaningful when the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Proposal_BulkMemoryOperations` or the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the function instance context to convert to the reference.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the function reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenFuncRef (Cxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the function reference WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The values generated by this function are only meaningful when the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Ref the reference to the external object.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Value struct with the external reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenExternRef (Ref : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the I32 value from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns I32 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetI32 (Val : WasmEdge_Value) -&gt; i32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the I64 value from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns I64 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetI64 (Val : WasmEdge_Value) -&gt; i64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the F32 value from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns F32 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetF32 (Val : WasmEdge_Value) -&gt; f32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the F64 value from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns F64 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetF64 (Val : WasmEdge_Value) -&gt; f64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the V128 value from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns V128 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetV128 (Val : WasmEdge_Value) -&gt; int128_t ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Specify the WASM value is a null reference or not.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the value is a null reference, false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueIsNullRef (Val : WasmEdge_Value) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the function instance context from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to function instance context in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetFuncRef (Val : WasmEdge_Value) -&gt; * <span class="kw">const </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the external reference from the WASM value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Val the WasmEdge_Value struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns external reference in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetExternRef (Val : WasmEdge_Value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_String with the C string.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_StringDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it. This function only supports the C string with NULL termination.&quot;</span>] # [doc = <span class="string">&quot; If the input string may have `\\0` character, please use the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_StringCreateByBuffer` instead.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Str the NULL-terminated C string to copy into the WasmEdge_String&quot;</span>] # [doc = <span class="string">&quot; object.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed or&quot;</span>] # [doc = <span class="string">&quot; the input string is a NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCreateByCString (Str : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_String with the buffer and its length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_StringDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer to copy into the WasmEdge_String object.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed or&quot;</span>] # [doc = <span class="string">&quot; the input buffer is a NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCreateByBuffer (Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Create the WasmEdge_String wraps to the buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function creates a `WasmEdge_String` object which wraps to the input&quot;</span>] # [doc = <span class="string">&quot; buffer. The caller should guarantee the life cycle of the input buffer, and&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer to copy into the WasmEdge_String object.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object refer to the input buffer with its length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringWrap (Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compare the two WasmEdge_String objects.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Str1 the first WasmEdge_String object to compare.&quot;</span>] # [doc = <span class="string">&quot; \\param Str2 the second WasmEdge_String object to compare.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the content of two WasmEdge_String objects are the same,&quot;</span>] # [doc = <span class="string">&quot; false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringIsEqual (Str1 : WasmEdge_String , Str2 : WasmEdge_String) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the content of WasmEdge_String object to the buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function copy at most `Len` characters from the `WasmEdge_String`&quot;</span>] # [doc = <span class="string">&quot; object to the destination buffer. If the string length is less than `Len`&quot;</span>] # [doc = <span class="string">&quot; characters long, the remainder of the buffer is filled with `\\0&#39; characters.&quot;</span>] # [doc = <span class="string">&quot; Otherwise, the destination is not terminated.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Str the source WasmEdge_String object to copy.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer to fill the string content.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the copied length of string.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCopy (Str : WasmEdge_String , Buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the resources in the WasmEdge_String object&quot;</span>] # [doc = <span class="string">&quot; will be released and the object should __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Str the WasmEdge_String object to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringDelete (Str : WasmEdge_String) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check the result is a success or not.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Res the WasmEdge_Result struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the error code is WasmEdge_Result_Success or&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_Result_Terminate, false for others.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultOK (Res : WasmEdge_Result) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the result with code.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Category the WasmEdge_ErrCategory to specify the error category.&quot;</span>] # [doc = <span class="string">&quot; \\param Code the 24-bit length error code. The data exceeds 24 bits will be&quot;</span>] # [doc = <span class="string">&quot; stripped.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result struct with the given data.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGen (Category : WasmEdge_ErrCategory , Code : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the result code.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Res the WasmEdge_Result struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns result code (24-bit size data) in the WasmEdge_Result struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetCode (Res : WasmEdge_Result) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the error category.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Res the WasmEdge_Result struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns error category in the WasmEdge_Result struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetCategory (Res : WasmEdge_Result) -&gt; WasmEdge_ErrCategory ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the result message.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string must __NOT__ be destroyed.&quot;</span>] # [doc = <span class="string">&quot; If the error category of the result is __NOT__ `WasmEdge_ErrCategory_WASM`,&quot;</span>] # [doc = <span class="string">&quot; the message will always be \&quot;user defined error code\&quot;.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Res the WasmEdge_Result struct.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns NULL-terminated C string of the corresponding error message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetMessage (Res : WasmEdge_Result) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compare the two WasmEdge_Limit objects.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Lim1 the first WasmEdge_Limit object to compare.&quot;</span>] # [doc = <span class="string">&quot; \\param Lim2 the second WasmEdge_Limit object to compare.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the content of two WasmEdge_Limit objects are the same,&quot;</span>] # [doc = <span class="string">&quot; false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LimitIsEqual (Lim1 : WasmEdge_Limit , Lim2 : WasmEdge_Limit) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_ConfigureDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_ConfigureContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a proposal setting into the WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; For turning on a specific WASM proposal in WasmEdge_VMContext, you can set&quot;</span>] # [doc = <span class="string">&quot; the proposal value into the WasmEdge_ConfigureContext and create VM with&quot;</span>] # [doc = <span class="string">&quot; this context.&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_BulkMemoryOperations);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_ReferenceTypes);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_SIMD);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to add the proposal value.&quot;</span>] # [doc = <span class="string">&quot; \\param Prop the proposal value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureAddProposal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Remove a proposal setting in the WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to remove the proposal.&quot;</span>] # [doc = <span class="string">&quot; \\param Prop the proposal value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureRemoveProposal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check if a proposal setting exists in the WasmEdge_ConfigureContext or not.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to check the proposal value.&quot;</span>] # [doc = <span class="string">&quot; \\param Prop the proposal value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the proposal setting exists, false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureHasProposal (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a built-in host registration setting into WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; For turning on the Wasi support in `WasmEdge_VMContext`, you can set the&quot;</span>] # [doc = <span class="string">&quot; built-in host registration value into the `WasmEdge_ConfigureContext` and&quot;</span>] # [doc = <span class="string">&quot; create VM with this context.&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to add built-in host registration.&quot;</span>] # [doc = <span class="string">&quot; \\param Host the built-in host registration value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureAddHostRegistration (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Remove a built-in host registration setting in the&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to remove the host&quot;</span>] # [doc = <span class="string">&quot; pre-registration.&quot;</span>] # [doc = <span class="string">&quot; \\param Host the built-in host registration value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureRemoveHostRegistration (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check if a built-in host registration setting exists in the&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureContext or not.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to check the host pre-registration.&quot;</span>] # [doc = <span class="string">&quot; \\param Host the built-in host registration value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns true if the built-in host registration setting exists, false if&quot;</span>] # [doc = <span class="string">&quot; not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureHasHostRegistration (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the page limit of memory instances.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Limit the page count (64KiB per page) in memory instances.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the maximum page count.&quot;</span>] # [doc = <span class="string">&quot; \\param Page the maximum page count.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureSetMaxMemoryPage (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Page : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the page limit of memory instances.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the maximum page count&quot;</span>] # [doc = <span class="string">&quot; setting.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the page count limitation value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureGetMaxMemoryPage (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the force interpreter mode execution option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param isForceInterpreter the boolean value to determine to forcibly run&quot;</span>] # [doc = <span class="string">&quot; WASM in interpreter mode or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureSetForceInterpreter (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , isForceInterpreter : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the force interpreter mode execution option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to forcibly run WASM in interpreter&quot;</span>] # [doc = <span class="string">&quot; mode or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureIsForceInterpreter (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the optimization level of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the optimization level.&quot;</span>] # [doc = <span class="string">&quot; \\param Level the AOT compiler optimization level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetOptimizationLevel (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Level : WasmEdge_CompilerOptimizationLevel) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the optimization level of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the optimization level.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the AOT compiler optimization level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerGetOptimizationLevel (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; WasmEdge_CompilerOptimizationLevel ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the output binary format of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the output binary format.&quot;</span>] # [doc = <span class="string">&quot; \\param Format the AOT compiler output binary format.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetOutputFormat (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Format : WasmEdge_CompilerOutputFormat) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the output binary format of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the output binary format.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the AOT compiler output binary format.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerGetOutputFormat (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; WasmEdge_CompilerOutputFormat ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the dump IR option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsDump the boolean value to determine to dump IR or not when&quot;</span>] # [doc = <span class="string">&quot; compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetDumpIR (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsDump : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the dump IR option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to dump IR or not when compilation&quot;</span>] # [doc = <span class="string">&quot; in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsDumpIR (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the generic binary option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsGeneric the boolean value to determine to generate the generic&quot;</span>] # [doc = <span class="string">&quot; binary or not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetGenericBinary (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsGeneric : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the generic binary option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to generate the generic binary or&quot;</span>] # [doc = <span class="string">&quot; not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsGenericBinary (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the interruptible option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsInterruptible the boolean value to determine to generate&quot;</span>] # [doc = <span class="string">&quot; interruptible binary or not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetInterruptible (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsInterruptible : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the interruptible option of AOT compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to generate interruptible binary or&quot;</span>] # [doc = <span class="string">&quot; not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsInterruptible (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the instruction counting option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsCount the boolean value to determine to support instruction&quot;</span>] # [doc = <span class="string">&quot; counting when execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetInstructionCounting (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsCount : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction counting option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to support instruction counting when&quot;</span>] # [doc = <span class="string">&quot; execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsInstructionCounting (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the cost measuring option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsMeasure the boolean value to determine to support cost measuring&quot;</span>] # [doc = <span class="string">&quot; when execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetCostMeasuring (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsMeasure : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the cost measuring option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to support cost measuring when&quot;</span>] # [doc = <span class="string">&quot; execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsCostMeasuring (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the time measuring option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.&quot;</span>] # [doc = <span class="string">&quot; \\param IsMeasure the boolean value to determine to support time when&quot;</span>] # [doc = <span class="string">&quot; execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetTimeMeasuring (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsMeasure : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the time measuring option.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the boolean value to determine to support time measuring when&quot;</span>] # [doc = <span class="string">&quot; execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsTimeMeasuring (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ConfigureContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ConfigureContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_StatisticsContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_StatisticsDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_StatisticsContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction count in execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to get data.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the instruction count in total execution.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetInstrCount (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; u64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction count per second in execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to get data.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the instruction count per second.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetInstrPerSecond (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; f64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the total cost in execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to get data.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the total cost.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetTotalCost (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; u64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the costs of instructions.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to set the cost table.&quot;</span>] # [doc = <span class="string">&quot; \\param CostArr the cost table array.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the length of the cost table array.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsSetCostTable (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext , CostArr : * <span class="kw-2">mut </span>u64 , Len : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the cost limit in execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The WASM execution will be aborted if the instruction costs exceeded the&quot;</span>] # [doc = <span class="string">&quot; limit and the ErrCode::Value::CostLimitExceeded will be returned.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to set the cost table.&quot;</span>] # [doc = <span class="string">&quot; \\param Limit the cost limit.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsSetCostLimit (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext , Limit : u64) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Clear all data in the WasmEdge_StatisticsContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to clear.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsClear (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_StatisticsContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StatisticsContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of imports list of the AST module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the imports list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListImportsLength (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the imports of the AST module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; If the `Imports` buffer length is smaller than the result of the imports&quot;</span>] # [doc = <span class="string">&quot; list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Imports the import type contexts buffer. Can be NULL if import&quot;</span>] # [doc = <span class="string">&quot; types are not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListImports (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Imports : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_ImportTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exports list of the AST module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the exports list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListExportsLength (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exports of the AST module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; If the `Exports` buffer length is smaller than the result of the exports&quot;</span>] # [doc = <span class="string">&quot; list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Exports the export type contexts buffer. Can be NULL if export&quot;</span>] # [doc = <span class="string">&quot; types are not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListExports (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Exports : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_ExportTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASTModuleContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ASTModuleContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_FunctionTypeDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ParamList the value types list of parameters. NULL if the length is&quot;</span>] # [doc = <span class="string">&quot; 0.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the ParamList buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnList the value types list of returns. NULL if the length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the ReturnList buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeCreate (ParamList : * <span class="kw">const </span>WasmEdge_ValType , ParamLen : u32 , ReturnList : * <span class="kw">const </span>WasmEdge_ValType , ReturnLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the parameter types list length from the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the parameter types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetParametersLength (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the parameter types list from the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; If the `List` buffer length is smaller than the length of the parameter type&quot;</span>] # [doc = <span class="string">&quot; list, the overflowed values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] List the WasmEdge_ValType buffer to fill the parameter value&quot;</span>] # [doc = <span class="string">&quot; types.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the value type buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the actual parameter types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetParameters (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , List : * <span class="kw-2">mut </span>WasmEdge_ValType , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the return types list length from the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the return types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetReturnsLength (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the return types list from the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; If the `List` buffer length is smaller than the length of the return type&quot;</span>] # [doc = <span class="string">&quot; list, the overflowed values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] List the WasmEdge_ValType buffer to fill the return value&quot;</span>] # [doc = <span class="string">&quot; types.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the value type buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the actual return types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetReturns (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , List : * <span class="kw-2">mut </span>WasmEdge_ValType , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_FunctionTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_FunctionTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_TableTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_TableTypeDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param RefType the reference type of the table type.&quot;</span>] # [doc = <span class="string">&quot; \\param Limit the limit struct of the table type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeCreate (RefType : WasmEdge_RefType , Limit : WasmEdge_Limit) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the reference type from a table type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the reference type of the table type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeGetRefType (Cxt : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; WasmEdge_RefType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the limit from a table type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the limit struct of the table type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeGetLimit (Cxt : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; WasmEdge_Limit ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_TableTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_MemoryTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_MemoryTypeDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Limit the limit struct of the memory type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeCreate (Limit : WasmEdge_Limit) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the limit from a memory type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the limit struct of the memory type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeGetLimit (Cxt : * <span class="kw">const </span>WasmEdge_MemoryTypeContext) -&gt; WasmEdge_Limit ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_MemoryTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_GlobalTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_GlobalTypeDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ValType the value type of the global type.&quot;</span>] # [doc = <span class="string">&quot; \\param Mut the mutation of the global type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeCreate (ValType : WasmEdge_ValType , Mut : WasmEdge_Mutability) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the value type from a global type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the value type of the global type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeGetValType (Cxt : * <span class="kw">const </span>WasmEdge_GlobalTypeContext) -&gt; WasmEdge_ValType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the mutability from a global type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the mutability of the global type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeGetMutability (Cxt : * <span class="kw">const </span>WasmEdge_GlobalTypeContext) -&gt; WasmEdge_Mutability ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_GlobalTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external type from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the external type of the import type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetExternalType (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_ExternalType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module name from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string object is linked to the module name of the import type,&quot;</span>] # [doc = <span class="string">&quot; and the caller should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetModuleName (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external name from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string object is linked to the external name of the import&quot;</span>] # [doc = <span class="string">&quot; type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetExternalName (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is function type) from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The import type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The function type context links to the function type in the import type&quot;</span>] # [doc = <span class="string">&quot; context and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_FunctionTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the function type. NULL if failed or the external type of the&quot;</span>] # [doc = <span class="string">&quot; import type is not `WasmEdge_ExternalType_Function`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetFunctionType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is table type) from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The import type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The table type context links to the table type in the import type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_TableTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the table type. NULL if failed or the external type of the import&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Table`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetTableType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is memory type) from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The import type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The memory type context links to the memory type in the import type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_MemoryTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the memory type. NULL if failed or the external type of the import&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Memory`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetMemoryType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is global type) from an import type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The import type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The global type context links to the global type in the import type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_GlobalTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the global type. NULL if failed or the external type of the import&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Global`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetGlobalType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external type from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the external type of the export type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetExternalType (Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; WasmEdge_ExternalType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external name from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string object is linked to the external name of the export&quot;</span>] # [doc = <span class="string">&quot; type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetExternalName (Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is function type) from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The export type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The function type context links to the function type in the export type&quot;</span>] # [doc = <span class="string">&quot; context and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_FunctionTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the function type. NULL if failed or the external type of the&quot;</span>] # [doc = <span class="string">&quot; export type is not `WasmEdge_ExternalType_Function`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetFunctionType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is table type) from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The export type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The table type context links to the table type in the export type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_TableTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the table type. NULL if failed or the external type of the export&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Table`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetTableType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is memory type) from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The export type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The memory type context links to the memory type in the export type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_MemoryTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the memory type. NULL if failed or the external type of the export&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Memory`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetMemoryType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is global type) from an export type.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The export type context should be the one queried from the AST module&quot;</span>] # [doc = <span class="string">&quot; context, or this function will cause unexpected error.&quot;</span>] # [doc = <span class="string">&quot; The global type context links to the global type in the export type context&quot;</span>] # [doc = <span class="string">&quot; and the AST module context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_GlobalTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the global type. NULL if failed or the external type of the export&quot;</span>] # [doc = <span class="string">&quot; type is not `WasmEdge_ExternalType_Global`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetGlobalType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_CompilerContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_CompilerDelete` to&quot;</span>] # [doc = <span class="string">&quot; delete it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_CompilerContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compile the input WASM from the file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The compiler compiles the WASM from file path for the ahead-of-time mode and&quot;</span>] # [doc = <span class="string">&quot; store the result to the output file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CompilerContext.&quot;</span>] # [doc = <span class="string">&quot; \\param InPath the input WASM file path.&quot;</span>] # [doc = <span class="string">&quot; \\param OutPath the output WASM file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCompile (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext , InPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char , OutPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compile the input WASM from the given buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The compiler compiles the WASM from the given buffer for the&quot;</span>] # [doc = <span class="string">&quot; ahead-of-time mode and store the result to the output file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CompilerContext.&quot;</span>] # [doc = <span class="string">&quot; \\param InBuffer the input WASM binary buffer.&quot;</span>] # [doc = <span class="string">&quot; \\param InBufferLen the length of the input WASM binary buffer.&quot;</span>] # [doc = <span class="string">&quot; \\param OutPath the output WASM file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCompileFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext , InBuffer : * <span class="kw">const </span>u8 , InBufferLen : u64 , OutPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_CompilerContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CompilerContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_LoaderContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_LoaderDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of Loader.&quot;</span>] # [doc = <span class="string">&quot; NULL for the default configuration.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_LoaderContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load and parse the WASM module from a WASM file into a&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Load and parse the WASM module from the file path, and return a&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ASTModuleContext` as the result. The caller owns the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ASTModuleContext` object and should call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ASTModuleDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_LoaderContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.&quot;</span>] # [doc = <span class="string">&quot; \\param Path the NULL-terminated C string of the WASM file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderParseFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext , Module : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ASTModuleContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load and parse the WASM module from a buffer into WasmEdge_ASTModuleContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Load and parse the WASM module from a buffer, and return a&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ASTModuleContext as the result. The caller owns the&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ASTModuleContext object and should call `WasmEdge_ASTModuleDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_LoaderContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer of WASM binary.&quot;</span>] # [doc = <span class="string">&quot; \\param BufLen the length of the buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderParseFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext , Module : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ASTModuleContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_LoaderContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_LoaderContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ValidatorContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_ValidatorDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of&quot;</span>] # [doc = <span class="string">&quot; Validator. NULL for the default configuration.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ValidatorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Validate the WasmEdge AST Module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ValidatorContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge_ASTModuleContext to validate.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorValidate (Cxt : * <span class="kw-2">mut </span>WasmEdge_ValidatorContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ValidatorContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ValidatorContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ValidatorContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ExecutorContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_ExecutorDelete` to&quot;</span>] # [doc = <span class="string">&quot; delete it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of&quot;</span>] # [doc = <span class="string">&quot; Executor. NULL for the default configuration.&quot;</span>] # [doc = <span class="string">&quot; \\param StatCxt the WasmEdge_StatisticsContext as the statistics object set&quot;</span>] # [doc = <span class="string">&quot; into Executor. The statistics will refer to this context, and the life cycle&quot;</span>] # [doc = <span class="string">&quot; should be ensured until the executor context is deleted. NULL for not doing&quot;</span>] # [doc = <span class="string">&quot; the statistics.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , StatCxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate an AST Module into a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Instantiate an AST Module, and return an instantiated&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ASTModuleContext as the result. The caller owns the object and&quot;</span>] # [doc = <span class="string">&quot; should call `WasmEdge_ModuleInstanceDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot; Developers can use the `WasmEdge_ModuleInstanceListFunction`,&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported&quot;</span>] # [doc = <span class="string">&quot; instances from the result module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if&quot;</span>] # [doc = <span class="string">&quot; succeeded.&quot;</span>] # [doc = <span class="string">&quot; \\param StoreCxt the WasmEdge_StoreContext to link the imports.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorInstantiate (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , ModuleCxt : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate and register an AST Module into a named module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Instantiate an AST Module with the module name, and return an instantiated&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ASTModuleContext as the result. The caller owns the object and&quot;</span>] # [doc = <span class="string">&quot; should call `WasmEdge_ModuleInstanceDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot; Developers can use the `WasmEdge_ModuleInstanceListFunction`,&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported&quot;</span>] # [doc = <span class="string">&quot; instances from the result module instance.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the module is registered into the store, and&quot;</span>] # [doc = <span class="string">&quot; the other modules can import the instances for linking when instantiation.&quot;</span>] # [doc = <span class="string">&quot; Developers should guarantee the life cycle of this registered module&quot;</span>] # [doc = <span class="string">&quot; instance, or the error will occur when in execution after the module&quot;</span>] # [doc = <span class="string">&quot; instance destroyed if it has been imported by other modules.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if&quot;</span>] # [doc = <span class="string">&quot; succeeded.&quot;</span>] # [doc = <span class="string">&quot; \\param StoreCxt the WasmEdge_StoreContext to link the imports.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String for all exported&quot;</span>] # [doc = <span class="string">&quot; instances.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorRegister (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , ModuleCxt : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , ModuleName : WasmEdge_String) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a module instance into a store with exporting its module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Register an existing module into the store with its module name.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the module instance is registered into the&quot;</span>] # [doc = <span class="string">&quot; store, and the other modules can import the instances for linking when&quot;</span>] # [doc = <span class="string">&quot; instantiation. Developers should guarantee the life cycle of this registered&quot;</span>] # [doc = <span class="string">&quot; module instance, or the error will occur when in execution after the module&quot;</span>] # [doc = <span class="string">&quot; instance destroyed if it has been imported by other modules.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.&quot;</span>] # [doc = <span class="string">&quot; \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module.&quot;</span>] # [doc = <span class="string">&quot; \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorRegisterImport (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ImportCxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by the function instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After instantiating a WASM module, developers can get the function instance&quot;</span>] # [doc = <span class="string">&quot; context from the module instance. Then developers can invoke the function&quot;</span>] # [doc = <span class="string">&quot; through this API.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExecutorContext.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncCxt the function instance context to invoke.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorInvoke (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , FuncCxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ExecutorContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ExecutorContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_StoreContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_StoreDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_StoreContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance context by the module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After registering a WASM module, you can call this function to get the&quot;</span>] # [doc = <span class="string">&quot; registered module instance context by the module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StoreContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the module name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreFindModule (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext , Name : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of registered module list in store.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StoreContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of registered named module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreListModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the registered module names.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will list all registered module names.&quot;</span>] # [doc = <span class="string">&quot; The returned module names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; registered module names in the store context, and the caller should __NOT__&quot;</span>] # [doc = <span class="string">&quot; call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the registered&quot;</span>] # [doc = <span class="string">&quot; named module list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StoreContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output names WasmEdge_String buffer of named modules.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual registered named module list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreListModule (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_StoreContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_StoreContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Create a module instance context with exported module name for host&quot;</span>] # [doc = <span class="string">&quot; instances. Developer can use this API to create a module instance for&quot;</span>] # [doc = <span class="string">&quot; collecting host functions, tables, memories, and globals.&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String of this host module to&quot;</span>] # [doc = <span class="string">&quot; import.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceCreate (ModuleName : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ModuleInstanceContext for the WASI specification.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will create a WASI host module that contains the WASI host&quot;</span>] # [doc = <span class="string">&quot; functions and initialize it. The caller owns the object and should call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ModuleInstanceDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Args the command line arguments. The first argument suggests being&quot;</span>] # [doc = <span class="string">&quot; the program name. NULL if the length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param ArgLen the length of the command line arguments.&quot;</span>] # [doc = <span class="string">&quot; \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the&quot;</span>] # [doc = <span class="string">&quot; length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param EnvLen the length of the environment variables.&quot;</span>] # [doc = <span class="string">&quot; \\param Preopens the directory paths to preopen. String format in&quot;</span>] # [doc = <span class="string">&quot; `PATH1:PATH2` means the path mapping, or the same path will be mapped. NULL&quot;</span>] # [doc = <span class="string">&quot; if the length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param PreopenLen the length of the directory paths to preopen.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceCreateWASI (Args : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , ArgLen : u32 , Envs : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , EnvLen : u32 , Preopens : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , PreopenLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Initialize the WasmEdge_ModuleInstanceContext for the WASI specification.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will initialize the WASI host module with the parameters.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.&quot;</span>] # [doc = <span class="string">&quot; \\param Args the command line arguments. The first argument suggests being&quot;</span>] # [doc = <span class="string">&quot; the program name. NULL if the length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param ArgLen the length of the command line arguments.&quot;</span>] # [doc = <span class="string">&quot; \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the&quot;</span>] # [doc = <span class="string">&quot; length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param EnvLen the length of the environment variables.&quot;</span>] # [doc = <span class="string">&quot; \\param Preopens the directory paths to preopen. String format in&quot;</span>] # [doc = <span class="string">&quot; `PATH1:PATH2` means the path mapping, or the same path will be mapped. NULL&quot;</span>] # [doc = <span class="string">&quot; if the length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param PreopenLen the length of the directory paths to preopen.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceInitWASI (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Args : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , ArgLen : u32 , Envs : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , EnvLen : u32 , Preopens : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , PreopenLen : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the WASI exit code.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will return the exit code after running the \&quot;_start\&quot; function&quot;</span>] # [doc = <span class="string">&quot; of a `wasm32-wasi` program.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the exit code after executing the \&quot;_start\&quot; function. Return&quot;</span>] # [doc = <span class="string">&quot; `EXIT_FAILURE` if the `Cxt` is NULL or not a WASI host module.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceWASIGetExitCode (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the native handler from the WASI mapped FD/Handler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will return the raw FD/Handler from a given mapped Fd&quot;</span>] # [doc = <span class="string">&quot; or Handler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.&quot;</span>] # [doc = <span class="string">&quot; \\param Fd the WASI mapped Fd.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] NativeHandler the raw Fd/Handler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the error code. Return `0` if the Native Handler is found.&quot;</span>] # [doc = <span class="string">&quot; Return `1` if the `Cxt` is `NULL`.&quot;</span>] # [doc = <span class="string">&quot; Return `2` if the given mapped Fd/handler is not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceWASIGetNativeHandler (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Fd : i32 , NativeHandler : * <span class="kw-2">mut </span>u64) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Initialize the WasmEdge_ModuleInstanceContext for the wasmedge_process&quot;</span>] # [doc = <span class="string">&quot; specification.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will initialize the wasmedge_process host module with the&quot;</span>] # [doc = <span class="string">&quot; parameters.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param AllowedCmds the allowed commands white list. NULL if the&quot;</span>] # [doc = <span class="string">&quot; length is 0.&quot;</span>] # [doc = <span class="string">&quot; \\param CmdsLen the length of the allowed commands white list.&quot;</span>] # [doc = <span class="string">&quot; \\param AllowAll the boolean value to allow all commands. `false` is&quot;</span>] # [doc = <span class="string">&quot; suggested. If this value is `true`, the allowed commands white list will not&quot;</span>] # [doc = <span class="string">&quot; be recorded and all commands can be executed by wasmedge_process.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceInitWasmEdgeProcess (AllowedCmds : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , CmdsLen : u32 , AllowAll : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the export module name of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string object is linked to the module name of the module&quot;</span>] # [doc = <span class="string">&quot; instance, and the caller should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceGetModuleName (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported function instance context of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The result function instance context links to the function instance in the&quot;</span>] # [doc = <span class="string">&quot; module instance context and owned by the module instance context, and the&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_FunctionInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the function instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindFunction (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported table instance context of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The result table instance context links to the table instance in the module&quot;</span>] # [doc = <span class="string">&quot; instance context and owned by the module instance context, and the caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_TableInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the table name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the table instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindTable (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported memory instance context of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The result memory instance context links to the memory instance in the&quot;</span>] # [doc = <span class="string">&quot; module instance context and owned by the module instance context, and the&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_MemoryInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the memory name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the memory instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindMemory (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported global instance context of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The result global instance context links to the global instance in the&quot;</span>] # [doc = <span class="string">&quot; module instance context and owned by the module instance context, and the&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_GlobalInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the global name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the global instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindGlobal (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported function list of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the exported function list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListFunctionLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported function names of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned function names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; exported names of functions of the module instance context, and the caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the exported&quot;</span>] # [doc = <span class="string">&quot; function list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the function names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListFunction (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported table list of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the exported table list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListTableLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported table names of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned table names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; exported names of tables of the module instance context, and the caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the exported&quot;</span>] # [doc = <span class="string">&quot; table list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the table names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported table list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListTable (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported memory list of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the exported memory list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListMemoryLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported memory names of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned memory names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; exported names of memories of the module instance context, and the caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the exported&quot;</span>] # [doc = <span class="string">&quot; memory list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the memory names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported memory list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListMemory (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported global list of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of the exported global list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListGlobalLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported global names of a module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned global names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; exported names of globals of the module instance context, and the caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the exported&quot;</span>] # [doc = <span class="string">&quot; global list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the global names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported global list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListGlobal (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a function instance context into a WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Export and move the ownership of the function instance into the module&quot;</span>] # [doc = <span class="string">&quot; instance. The caller should __NOT__ access or destroy the function instance&quot;</span>] # [doc = <span class="string">&quot; context after calling this function.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext to add the function instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the export function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncCxt the WasmEdge_FunctionInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddFunction (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , FuncCxt : * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a table instance context into a WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Export and move the ownership of the table instance into the module&quot;</span>] # [doc = <span class="string">&quot; instance. The caller should __NOT__ access or destroy the table instance&quot;</span>] # [doc = <span class="string">&quot; context after calling this function.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext to add the table instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the export table name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param TableCxt the WasmEdge_TableInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddTable (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , TableCxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a memory instance context into a WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Export and move the ownership of the memory instance into the module&quot;</span>] # [doc = <span class="string">&quot; instance. The caller should __NOT__ access or destroy the memory instance&quot;</span>] # [doc = <span class="string">&quot; context after calling this function.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext to add the memory instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the export memory name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param MemoryCxt the WasmEdge_MemoryInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddMemory (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , MemoryCxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a global instance context into a WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Export and move the ownership of the global instance into the module&quot;</span>] # [doc = <span class="string">&quot; instance. The caller should __NOT__ access or destroy the global instance&quot;</span>] # [doc = <span class="string">&quot; context after calling this function.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext to add the global instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Name the export global name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param GlobalCxt the WasmEdge_GlobalInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddGlobal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , GlobalCxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ModuleInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ModuleInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext) ; } <span class="kw">pub type </span>WasmEdge_HostFunc_t = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , CallFrameCxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Params : * <span class="kw">const </span>WasmEdge_Value , Returns : * <span class="kw-2">mut </span>WasmEdge_Value) -&gt; WasmEdge_Result &gt; ; <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionInstanceContext for host functions.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_FunctionInstanceDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it if the returned object is not added into a&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_ModuleInstanceContext`. The following is an example to create a&quot;</span>] # [doc = <span class="string">&quot; host function context.&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_Result FuncAdd(void *Data,&quot;</span>] # [doc = <span class="string">&quot;                         const WasmEdge_CallingFrameContext *CallFrameCxt,&quot;</span>] # [doc = <span class="string">&quot;                         const WasmEdge_Value *In, WasmEdge_Value *Out) {&quot;</span>] # [doc = <span class="string">&quot;   // Function to return A + B.&quot;</span>] # [doc = <span class="string">&quot;   int32_t A = WasmEdge_ValueGetI32(In[0]);&quot;</span>] # [doc = <span class="string">&quot;   int32_t B = WasmEdge_ValueGetI32(In[1]);&quot;</span>] # [doc = <span class="string">&quot;   Out[0] = WasmEdge_ValueGenI32(A + B);&quot;</span>] # [doc = <span class="string">&quot;   // Return execution status&quot;</span>] # [doc = <span class="string">&quot;   return WasmEdge_Result_Success;&quot;</span>] # [doc = <span class="string">&quot; }&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,&quot;</span>] # [doc = <span class="string">&quot;                                    WasmEdge_ValType_I32};&quot;</span>] # [doc = <span class="string">&quot; enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionTypeContext *FuncType =&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionInstanceContext *HostFunc =&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_FunctionInstanceCreate(FuncType, FuncAdd, NULL, 0);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionTypeDelete(FuncType);&quot;</span>] # [doc = <span class="string">&quot; ...&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Type the function type context to describe the host function&quot;</span>] # [doc = <span class="string">&quot; signature.&quot;</span>] # [doc = <span class="string">&quot; \\param HostFunc the host function pointer. The host function signature must&quot;</span>] # [doc = <span class="string">&quot; be as following:&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(&quot;</span>] # [doc = <span class="string">&quot;     void *Data,&quot;</span>] # [doc = <span class="string">&quot;     const WasmEdge_CallingFrameContext *CallFrameCxt,&quot;</span>] # [doc = <span class="string">&quot;     const WasmEdge_Value *Params,&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_Value *Returns);&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot; The `Params` is the input parameters array with length guaranteed to be the&quot;</span>] # [doc = <span class="string">&quot; same as the parameter types in the `Type`. The `Returns` is the output&quot;</span>] # [doc = <span class="string">&quot; results array with length guaranteed to be the same as the result types in&quot;</span>] # [doc = <span class="string">&quot; the `Type`. The return value is `WasmEdge_Result` for the execution status.&quot;</span>] # [doc = <span class="string">&quot; \\param Data the additional object, such as the pointer to a data structure,&quot;</span>] # [doc = <span class="string">&quot; to set to this host function context. The caller should guarantee the life&quot;</span>] # [doc = <span class="string">&quot; cycle of the object. NULL if the additional data object is not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param Cost the function cost in statistics. Pass 0 if the calculation is&quot;</span>] # [doc = <span class="string">&quot; not needed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceCreate (Type : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , HostFunc : WasmEdge_HostFunc_t , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Cost : u64) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">pub type </span>WasmEdge_WrapFunc_t = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(This : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , CallFrameCxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result &gt; ; <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionInstanceContext for host functions.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is for the languages which cannot pass the function pointer of&quot;</span>] # [doc = <span class="string">&quot; the host function into this shared library directly. The caller owns the&quot;</span>] # [doc = <span class="string">&quot; object and should call `WasmEdge_FunctionInstanceDelete` to destroy it if&quot;</span>] # [doc = <span class="string">&quot; the returned object is not added into a `WasmEdge_ModuleInstanceContext`.&quot;</span>] # [doc = <span class="string">&quot; The following is an example to create a host function context for other&quot;</span>] # [doc = <span class="string">&quot; languages.&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; // `RealFunc` is the pointer to the function in other languages.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_Result FuncAddWrap(&quot;</span>] # [doc = <span class="string">&quot;     void *This, void *Data,&quot;</span>] # [doc = <span class="string">&quot;     const WasmEdge_CallingFrameContext *CallFrameCxt,&quot;</span>] # [doc = <span class="string">&quot;     const WasmEdge_Value *In, const uint32_t InLen, WasmEdge_Value *Out,&quot;</span>] # [doc = <span class="string">&quot;     const uint32_t OutLen) {&quot;</span>] # [doc = <span class="string">&quot;   // Wrapper function of host function to return A + B.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot;   // `This` is the same as `RealFunc`.&quot;</span>] # [doc = <span class="string">&quot;   int32_t A = WasmEdge_ValueGetI32(In[0]);&quot;</span>] # [doc = <span class="string">&quot;   int32_t B = WasmEdge_ValueGetI32(In[1]);&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot;   // Call the function of `This` in the host language ...&quot;</span>] # [doc = <span class="string">&quot;   int32_t Result = ...;&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot;   Out[0] = Result;&quot;</span>] # [doc = <span class="string">&quot;   // Return the execution status.&quot;</span>] # [doc = <span class="string">&quot;   return WasmEdge_Result_Success;&quot;</span>] # [doc = <span class="string">&quot; }&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,&quot;</span>] # [doc = <span class="string">&quot;                                    WasmEdge_ValType_I32};&quot;</span>] # [doc = <span class="string">&quot; enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionTypeContext *FuncType =&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionInstanceContext *HostFunc =&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_FunctionInstanceCreateBinding(&quot;</span>] # [doc = <span class="string">&quot;         FuncType, FuncAddWrap, RealFunc, NULL, 0);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_FunctionTypeDelete(FuncType);&quot;</span>] # [doc = <span class="string">&quot; ...&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Type the function type context to describe the host function&quot;</span>] # [doc = <span class="string">&quot; signature.&quot;</span>] # [doc = <span class="string">&quot; \\param WrapFunc the wrapper function pointer. The wrapper function signature&quot;</span>] # [doc = <span class="string">&quot; must be as following:&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(&quot;</span>] # [doc = <span class="string">&quot;     void *This,&quot;</span>] # [doc = <span class="string">&quot;     void *Data,&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_CallingFrameContext *FrameCxt,&quot;</span>] # [doc = <span class="string">&quot;     const WasmEdge_Value *Params,&quot;</span>] # [doc = <span class="string">&quot;     const uint32_t ParamLen,&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_Value *Returns,&quot;</span>] # [doc = <span class="string">&quot;     const uint32_t ReturnLen);&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot; The `This` is the pointer the same as the `Binding` parameter of this&quot;</span>] # [doc = <span class="string">&quot; function. The `Params` is the input parameters array with length guaranteed&quot;</span>] # [doc = <span class="string">&quot; to be the same as the parameter types in the `Type`, and the `ParamLen` is&quot;</span>] # [doc = <span class="string">&quot; the length of the array. The `Returns` is the output results array with&quot;</span>] # [doc = <span class="string">&quot; length guaranteed to be the same as the result types in the `Type`, and the&quot;</span>] # [doc = <span class="string">&quot; `ReturnLen` is the length of the array. The return value is&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_Result` for the execution status.&quot;</span>] # [doc = <span class="string">&quot; \\param Binding the `this` pointer of the host function target or the&quot;</span>] # [doc = <span class="string">&quot; function indexing maintained by the caller which can specify the host&quot;</span>] # [doc = <span class="string">&quot; function. When invoking the host function, this pointer will be the first&quot;</span>] # [doc = <span class="string">&quot; argument of the wrapper function.&quot;</span>] # [doc = <span class="string">&quot; \\param Data the additional object, such as the pointer to a data structure,&quot;</span>] # [doc = <span class="string">&quot; to set to this host function context. The caller should guarantee the life&quot;</span>] # [doc = <span class="string">&quot; cycle of the object. NULL if the additional data object is not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param Cost the function cost in statistics. Pass 0 if the calculation is&quot;</span>] # [doc = <span class="string">&quot; not needed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceCreateBinding (Type : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , WrapFunc : WasmEdge_WrapFunc_t , Binding : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Cost : u64) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type context of the function instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The function type context links to the function type in the function&quot;</span>] # [doc = <span class="string">&quot; instance context and owned by the context. The caller should __NOT__ call&quot;</span>] # [doc = <span class="string">&quot; the `WasmEdge_FunctionTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceGetFunctionType (Cxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_FunctionInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_FunctionInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_TableInstanceDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param TabType the table type context to initialize the table instance&quot;</span>] # [doc = <span class="string">&quot; context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceCreate (TabType : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the table type context from a table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The table type context links to the table type in the table instance context&quot;</span>] # [doc = <span class="string">&quot; and owned by the context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_TableTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetTableType (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the reference value in a table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Data the result reference value.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the reference value offset (index) in the table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetData (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext , Data : * <span class="kw-2">mut </span>WasmEdge_Value , Offset : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the reference value into a table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Data the reference value to set into the table instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the reference value offset (index) in the table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceSetData (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext , Data : WasmEdge_Value , Offset : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the size of a table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the size of the table instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetSize (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Grow a table instance with a size.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Size the count of reference values to grow in the table instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGrow (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext , Size : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_TableInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_TableInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_MemoryInstanceDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param MemType the memory type context to initialize the memory instance&quot;</span>] # [doc = <span class="string">&quot; context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceCreate (MemType : * <span class="kw">const </span>WasmEdge_MemoryTypeContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the memory type context from a memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The memory type context links to the memory type in the memory instance&quot;</span>] # [doc = <span class="string">&quot; context and owned by the context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_MemoryTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetMemoryType (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the data to the output buffer from a memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Data the result data buffer of copying destination.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the data start offset in the memory instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Length the requested data length. If the `Offset + Length` is larger&quot;</span>] # [doc = <span class="string">&quot; than the data size in the memory instance, this function will failed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetData (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext , Data : * <span class="kw-2">mut </span>u8 , Offset : u32 , Length : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the data into a memory instance from the input buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Data the data buffer to copy.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the data start offset in the memory instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Length the data buffer length. If the `Offset + Length` is larger&quot;</span>] # [doc = <span class="string">&quot; than the data size in the memory instance, this function will failed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceSetData (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Data : * <span class="kw">const </span>u8 , Offset : u32 , Length : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the data pointer in a memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the data start offset in the memory instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Length the requested data length. If the `Offset + Length` is larger&quot;</span>] # [doc = <span class="string">&quot; than the data size in the memory instance, this function will return NULL.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the pointer to data with the start offset. NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPointer (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Offset : u32 , Length : u32) -&gt; * <span class="kw-2">mut </span>u8 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the const data pointer in a const memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Offset the data start offset in the memory instance.&quot;</span>] # [doc = <span class="string">&quot; \\param Length the requested data length. If the `Offset + Length` is larger&quot;</span>] # [doc = <span class="string">&quot; than the data size in the memory instance, this function will return NULL.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the pointer to data with the start offset. NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPointerConst (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext , Offset : u32 , Length : u32) -&gt; * <span class="kw">const </span>u8 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the current page size (64 KiB of each page) of a memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the page size of the memory instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPageSize (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Grow a memory instance with a page size.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Page the page count to grow in the memory instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGrowPage (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Page : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_MemoryInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_MemoryInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_GlobalInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_GlobalInstanceDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param GlobType the global type context to initialize the global instance&quot;</span>] # [doc = <span class="string">&quot; context.&quot;</span>] # [doc = <span class="string">&quot; \\param Value the initial value with its value type of the global instance.&quot;</span>] # [doc = <span class="string">&quot; This function will fail if the value type of `GlobType` and `Value` are not&quot;</span>] # [doc = <span class="string">&quot; the same.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceCreate (GlobType : * <span class="kw">const </span>WasmEdge_GlobalTypeContext , Value : WasmEdge_Value) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the global type context from a global instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The global type context links to the global type in the global instance&quot;</span>] # [doc = <span class="string">&quot; context and owned by the context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_GlobalTypeDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceGetGlobalType (Cxt : * <span class="kw">const </span>WasmEdge_GlobalInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the value from a global instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the current value of the global instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceGetValue (Cxt : * <span class="kw">const </span>WasmEdge_GlobalInstanceContext) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the value from a global instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will do nothing if the global context is set as the `Const`&quot;</span>] # [doc = <span class="string">&quot; mutation or the value type not matched.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalInstanceContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Value the value to set into the global context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceSetValue (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext , Value : WasmEdge_Value) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_GlobalInstanceContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_GlobalInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the executor context from the current calling frame.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CallingFrameContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the executor context, NULL if the Cxt is NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetExecutor (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance of the current calling frame.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; When a WASM function is executing and start to call a host function, a frame&quot;</span>] # [doc = <span class="string">&quot; with the module instance which the WASM function belongs to will be pushed&quot;</span>] # [doc = <span class="string">&quot; onto the stack. And therefore the calling frame context will record that&quot;</span>] # [doc = <span class="string">&quot; module instance.&quot;</span>] # [doc = <span class="string">&quot; So in one case that the module instance will be `NULL`: developers execute&quot;</span>] # [doc = <span class="string">&quot; the function instance which is a host function and not added into a module&quot;</span>] # [doc = <span class="string">&quot; instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CallingFrameContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the module instance of the current calling frame.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetModuleInstance (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the memory instance by index from the module instance of the current&quot;</span>] # [doc = <span class="string">&quot; calling frame.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; By default, a WASM module only have one memory instance after instantiation.&quot;</span>] # [doc = <span class="string">&quot; Therefore, developers can use:&quot;</span>] # [doc = <span class="string">&quot;   `WasmEdge_CallingFrameGetMemoryInstance(Cxt, 0)`&quot;</span>] # [doc = <span class="string">&quot; to get the memory instance in host function body.&quot;</span>] # [doc = <span class="string">&quot; This extension is for the WASM multiple memories proposal. After enabling&quot;</span>] # [doc = <span class="string">&quot; the proposal, there may be greater than 1 memory instances in a WASM module.&quot;</span>] # [doc = <span class="string">&quot; So developers can use this function to access the memory instances which are&quot;</span>] # [doc = <span class="string">&quot; not in 0 index.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_CallingFrameContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Idx the index of memory instance in the module instance.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the memory instance, NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetMemoryInstance (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Idx : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait a WasmEdge_Async execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncWait (Cxt : * <span class="kw">const </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait a WasmEdge_Async execution with timeout.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync.&quot;</span>] # [doc = <span class="string">&quot; \\param Milliseconds times to wait.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns Result of waiting, true for execution ended, false for timeout&quot;</span>] # [doc = <span class="string">&quot; occurred.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncWaitFor (Cxt : * <span class="kw">const </span>WasmEdge_Async , Milliseconds : u64) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Cancel a WasmEdge_Async execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncCancel (Cxt : * <span class="kw-2">mut </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait and get the return list length of the WasmEdge_Async execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will wait until the execution finished and return the return&quot;</span>] # [doc = <span class="string">&quot; value list length of the executed function. This function will return 0 if&quot;</span>] # [doc = <span class="string">&quot; the `Cxt` is NULL, the execution was failed, or the execution was canceled.&quot;</span>] # [doc = <span class="string">&quot; Developers can call the `WasmEdge_AsyncGet` to get the execution status and&quot;</span>] # [doc = <span class="string">&quot; the return values.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the return list length of the executed function.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncGetReturnsLength (Cxt : * <span class="kw">const </span>WasmEdge_Async) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait and get the result of WasmEdge_Async execution.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will wait until the execution finished and return the&quot;</span>] # [doc = <span class="string">&quot; execution status and the return values.&quot;</span>] # [doc = <span class="string">&quot; If the `Returns` buffer length is smaller than the arity of the function,&quot;</span>] # [doc = <span class="string">&quot; the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncGet (Cxt : * <span class="kw">const </span>WasmEdge_Async , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_Async.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_ASync to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_VMDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of VM.&quot;</span>] # [doc = <span class="string">&quot; NULL for the default configuration.&quot;</span>] # [doc = <span class="string">&quot; \\param StoreCxt the WasmEdge_StoreContext as the external WASM store of VM.&quot;</span>] # [doc = <span class="string">&quot; The instantiation and execution will refer to this store context, and the&quot;</span>] # [doc = <span class="string">&quot; life cycle should be ensured until the VM context is deleted. NULL for the&quot;</span>] # [doc = <span class="string">&quot; default store owned by `WasmEdge_VMContext`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_VMContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register and instantiate WASM into the store in VM from a WASM file.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Load a WASM file from the path, and register all exported instances and&quot;</span>] # [doc = <span class="string">&quot; instantiate them into the store into the VM with their exported name and&quot;</span>] # [doc = <span class="string">&quot; module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext which contains the store.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the WasmEdge_String of module name for all exported&quot;</span>] # [doc = <span class="string">&quot; instances.&quot;</span>] # [doc = <span class="string">&quot; \\param Path the NULL-terminated C string of the WASM file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register and instantiate WASM into the store in VM from a buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Load a WASM module from a buffer, and register all exported instances and&quot;</span>] # [doc = <span class="string">&quot; instantiate them into the store into the VM with their exported name and&quot;</span>] # [doc = <span class="string">&quot; module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext which contains the store.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the WasmEdge_String of module name for all exported&quot;</span>] # [doc = <span class="string">&quot; instances.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer of WASM binary.&quot;</span>] # [doc = <span class="string">&quot; \\param BufLen the length of the buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate and register an AST Module into a named module instance in VM.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Load from the AST Module, and register all exported instances and&quot;</span>] # [doc = <span class="string">&quot; instantiate them into the store in VM with their exported name and module&quot;</span>] # [doc = <span class="string">&quot; name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext which contains the store.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the WasmEdge_String of module name for all exported&quot;</span>] # [doc = <span class="string">&quot; instances.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a module instance into the store in VM with exporting its module&quot;</span>] # [doc = <span class="string">&quot; name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; Register an existing module into the store in VM with its module name.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the module instance is registered into the&quot;</span>] # [doc = <span class="string">&quot; store in VM, and the other modules can import the instances for linking when&quot;</span>] # [doc = <span class="string">&quot; instantiating other modules. Developers should guarantee the life cycle of&quot;</span>] # [doc = <span class="string">&quot; this registered module instance, or the error will occur when in execution&quot;</span>] # [doc = <span class="string">&quot; after the module instance destroyed if it has been imported by other&quot;</span>] # [doc = <span class="string">&quot; modules.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext which contains the store.&quot;</span>] # [doc = <span class="string">&quot; \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromImport (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ImportCxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WASM file and invoke a function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from the file path, and then invoke a&quot;</span>] # [doc = <span class="string">&quot; function by name and parameters. If the `Returns` buffer length is smaller&quot;</span>] # [doc = <span class="string">&quot; than the arity of the function, the overflowed return values will be&quot;</span>] # [doc = <span class="string">&quot; discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Path the NULL-terminated C string of the WASM file path.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a buffer and invoke a function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from a buffer, and then invoke a&quot;</span>] # [doc = <span class="string">&quot; function by name and parameters. If the `Returns` buffer length is smaller&quot;</span>] # [doc = <span class="string">&quot; than the arity of the function, the overflowed return values will be&quot;</span>] # [doc = <span class="string">&quot; discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer of WASM binary.&quot;</span>] # [doc = <span class="string">&quot; \\param BufLen the length of the buffer.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32 , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WasmEdge AST Module and invoke a function&quot;</span>] # [doc = <span class="string">&quot; by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from the WasmEdge AST Module, and then&quot;</span>] # [doc = <span class="string">&quot; invoke the function by name and parameters. If the `Returns` buffer length&quot;</span>] # [doc = <span class="string">&quot; is smaller than the arity of the function, the overflowed return values will&quot;</span>] # [doc = <span class="string">&quot; be discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WASM file and asynchronous invoke a&quot;</span>] # [doc = <span class="string">&quot; function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from the file path, and then invoke a&quot;</span>] # [doc = <span class="string">&quot; function by name and parameters. If the `Returns` buffer length is smaller&quot;</span>] # [doc = <span class="string">&quot; than the arity of the function, the overflowed return values will be&quot;</span>] # [doc = <span class="string">&quot; discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Path the NULL-terminated C string of the WASM file path.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a buffer and asynchronous invoke a function&quot;</span>] # [doc = <span class="string">&quot; by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from a buffer, and then invoke a&quot;</span>] # [doc = <span class="string">&quot; function by name and parameters. If the `Returns` buffer length is smaller&quot;</span>] # [doc = <span class="string">&quot; than the arity of the function, the overflowed return values will be&quot;</span>] # [doc = <span class="string">&quot; discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer of WASM binary.&quot;</span>] # [doc = <span class="string">&quot; \\param BufLen the length of the buffer.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32 , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WasmEdge AST Module and asynchronous&quot;</span>] # [doc = <span class="string">&quot; invoke a function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the function to invoke a WASM function rapidly.&quot;</span>] # [doc = <span class="string">&quot; Load and instantiate the WASM module from the WasmEdge AST Module, and then&quot;</span>] # [doc = <span class="string">&quot; invoke the function by name and parameters. If the `Returns` buffer length&quot;</span>] # [doc = <span class="string">&quot; is smaller than the arity of the function, the overflowed return values will&quot;</span>] # [doc = <span class="string">&quot; be discarded.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from a WASM file.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the first step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; Load and parse the WASM module from the file path. You can then call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_VMValidate` for the next step.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Path the NULL-terminated C string of the WASM file path.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from a buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the first step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; Load and parse the WASM module from a buffer. You can then call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_VMValidate` for the next step.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Buf the buffer of WASM binary.&quot;</span>] # [doc = <span class="string">&quot; \\param BufLen the length of the buffer.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from loaded WasmEdge AST Module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the first step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; Copy the loaded WasmEdge AST Module context into VM. The VM context has no&quot;</span>] # [doc = <span class="string">&quot; dependency on the input AST Module context. You can then call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_VMValidate` for the next step.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ASTCxt the WasmEdge AST Module context generated by loader or&quot;</span>] # [doc = <span class="string">&quot; compiler.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Validate the WASM module loaded into the VM context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the second step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; After loading a WASM module into VM context, You can call this function to&quot;</span>] # [doc = <span class="string">&quot; validate it. And you can then call `WasmEdge_VMInstantiate` for the next&quot;</span>] # [doc = <span class="string">&quot; step. Note that only validated WASM modules can be instantiated in the VM&quot;</span>] # [doc = <span class="string">&quot; context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMValidate (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the validated WASM module in the VM context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the third step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; After validating a WASM module in the VM context, You can call this function&quot;</span>] # [doc = <span class="string">&quot; to instantiate it. And you can then call `WasmEdge_VMExecute` for invoking&quot;</span>] # [doc = <span class="string">&quot; the exported function in this WASM module.&quot;</span>] # [doc = <span class="string">&quot; After calling this function, a new module instance is instantiated, and the&quot;</span>] # [doc = <span class="string">&quot; old one will be destroyed.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMInstantiate (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the final step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; After instantiating a WASM module in the VM context, the WASM module is&quot;</span>] # [doc = <span class="string">&quot; registered into the store in the VM context as an anonymous module. Then you&quot;</span>] # [doc = <span class="string">&quot; can repeatedly call this function to invoke the exported WASM functions by&quot;</span>] # [doc = <span class="string">&quot; their names until the VM context is reset or a new WASM module is registered&quot;</span>] # [doc = <span class="string">&quot; or loaded. For calling the functions in registered WASM modules with module&quot;</span>] # [doc = <span class="string">&quot; names, please use `WasmEdge_VMExecuteRegistered` instead. If the `Returns`&quot;</span>] # [doc = <span class="string">&quot; buffer length is smaller than the arity of the function, the overflowed&quot;</span>] # [doc = <span class="string">&quot; return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMExecute (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by its module name and function name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After registering a WASM module in the VM context, you can repeatedly call&quot;</span>] # [doc = <span class="string">&quot; this function to invoke exported WASM functions by their module names and&quot;</span>] # [doc = <span class="string">&quot; function names until the VM context is reset. If the `Returns` buffer length&quot;</span>] # [doc = <span class="string">&quot; is smaller than the arity of the function, the overflowed return values will&quot;</span>] # [doc = <span class="string">&quot; be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Returns the WasmEdge_Value buffer to fill the return values.&quot;</span>] # [doc = <span class="string">&quot; \\param ReturnLen the return buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error&quot;</span>] # [doc = <span class="string">&quot; message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMExecuteRegistered (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Asynchronous invoke a WASM function by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This is the final step to invoke a WASM function step by step.&quot;</span>] # [doc = <span class="string">&quot; After instantiating a WASM module in the VM context, the WASM module is&quot;</span>] # [doc = <span class="string">&quot; registered into the store in the VM context as an anonymous module. Then you&quot;</span>] # [doc = <span class="string">&quot; can repeatedly call this function to invoke the exported WASM functions by&quot;</span>] # [doc = <span class="string">&quot; their names until the VM context is reset or a new WASM module is registered&quot;</span>] # [doc = <span class="string">&quot; or loaded. For calling the functions in registered WASM modules with module&quot;</span>] # [doc = <span class="string">&quot; names, please use `WasmEdge_VMAsyncExecuteRegistered` instead.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncExecute (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Asynchronous invoke a WASM function by its module name and function name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After registering a WASM module in the VM context, you can repeatedly call&quot;</span>] # [doc = <span class="string">&quot; this function to invoke exported WASM functions by their module names and&quot;</span>] # [doc = <span class="string">&quot; function names until the VM context is reset.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param Params the WasmEdge_Value buffer with the parameter values.&quot;</span>] # [doc = <span class="string">&quot; \\param ParamLen the parameter buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncExecuteRegistered (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type by function name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After instantiating a WASM module in the VM context, the WASM module is&quot;</span>] # [doc = <span class="string">&quot; registered into the store in the VM context as an anonymous module. Then you&quot;</span>] # [doc = <span class="string">&quot; can call this function to get the function type by the exported function&quot;</span>] # [doc = <span class="string">&quot; name until the VM context is reset or a new WASM module is registered or&quot;</span>] # [doc = <span class="string">&quot; loaded. For getting the function type of functions in registered WASM&quot;</span>] # [doc = <span class="string">&quot; modules with module names, please use `WasmEdge_VMGetFunctionTypeRegistered`&quot;</span>] # [doc = <span class="string">&quot; instead.&quot;</span>] # [doc = <span class="string">&quot; The returned function type context are linked to the context owned by the VM&quot;</span>] # [doc = <span class="string">&quot; context, and the caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_FunctionTypeDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the function type. NULL if the function not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionType (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , FuncName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type by function name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After registering a WASM module in the VM context, you can call this&quot;</span>] # [doc = <span class="string">&quot; function to get the function type by the functions&#39; exported module names&quot;</span>] # [doc = <span class="string">&quot; and function names until the VM context is reset.&quot;</span>] # [doc = <span class="string">&quot; The returned function type context are linked to the context owned by the VM&quot;</span>] # [doc = <span class="string">&quot; context, and the caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_FunctionTypeDelete` to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot; \\param FuncName the function name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the function type. NULL if the function not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionTypeRegistered (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Reset of WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the statistics, loaded module, the instantiated&quot;</span>] # [doc = <span class="string">&quot; instances, and the registered instances except the WASI and plug-ins will&quot;</span>] # [doc = <span class="string">&quot; all be cleared.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext to reset.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMCleanup (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported function list.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of exported function list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionListLength (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported function list.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned function names filled into the `Names` array link to the&quot;</span>] # [doc = <span class="string">&quot; exported names of functions owned by the vm context, and the caller should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ call the `WasmEdge_StringDelete` to destroy them.&quot;</span>] # [doc = <span class="string">&quot; The function type contexts filled into the `FuncTypes` array of the&quot;</span>] # [doc = <span class="string">&quot; corresponding function names link to the context owned by the VM context.&quot;</span>] # [doc = <span class="string">&quot; The caller should __NOT__ call the `WasmEdge_FunctionTypeDelete` to destroy&quot;</span>] # [doc = <span class="string">&quot; them.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` and `FuncTypes` buffer lengths are smaller than the result of&quot;</span>] # [doc = <span class="string">&quot; the exported function list size, the overflowed return values will be&quot;</span>] # [doc = <span class="string">&quot; discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output names WasmEdge_String buffer of exported&quot;</span>] # [doc = <span class="string">&quot; functions. Can be NULL if names are not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] FuncTypes the function type contexts buffer. Can be NULL if&quot;</span>] # [doc = <span class="string">&quot; function types are not needed.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionList (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , FuncTypes : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_FunctionTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance corresponding to the WasmEdge_HostRegistration&quot;</span>] # [doc = <span class="string">&quot; settings.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; When creating the VM context with a configuration, the built-in host module&quot;</span>] # [doc = <span class="string">&quot; will be registered according to the `WasmEdge_HostRegistration` settings&quot;</span>] # [doc = <span class="string">&quot; added into the `WasmEdge_ConfigureContext`. You can call this function to&quot;</span>] # [doc = <span class="string">&quot; get the `WasmEdge_ModuleInstanceContext` corresponding to the settings. The&quot;</span>] # [doc = <span class="string">&quot; module instance context links to the context owned by the VM context. The&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; ```c&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);&quot;</span>] # [doc = <span class="string">&quot; WasmEdge_ModuleInstanceContext *WasiMod =&quot;</span>] # [doc = <span class="string">&quot;     WasmEdge_VMGetImportModuleContext(VM, WasmEdge_HostRegistration_Wasi);&quot;</span>] # [doc = <span class="string">&quot; ```&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param Reg the host registration value to get the import module.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetImportModuleContext (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Reg : WasmEdge_HostRegistration) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the current instantiated module in VM.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After instantiating a module instance into the VM, developers can call this&quot;</span>] # [doc = <span class="string">&quot; API to get the module instance to retrieve the exported instances. The&quot;</span>] # [doc = <span class="string">&quot; module instance context links to the context owned by the VM context. The&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetActiveModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the registered module in VM by the module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After registering a WASM module into the VM context, developers can call&quot;</span>] # [doc = <span class="string">&quot; this function to get the module instance by the module name. The returned&quot;</span>] # [doc = <span class="string">&quot; module instance context links to the context owned by the VM context, and&quot;</span>] # [doc = <span class="string">&quot; the caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete` to&quot;</span>] # [doc = <span class="string">&quot; destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetRegisteredModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , ModuleName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of registered module list in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of registered module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMListRegisteredModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the registered module names in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function will list all registered module names.&quot;</span>] # [doc = <span class="string">&quot; The returned module names filled into the `Names` array are linked to the&quot;</span>] # [doc = <span class="string">&quot; registered module names in the VM context, and the caller should __NOT__&quot;</span>] # [doc = <span class="string">&quot; call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the registered&quot;</span>] # [doc = <span class="string">&quot; named module list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output names WasmEdge_String buffer of the registered&quot;</span>] # [doc = <span class="string">&quot; modules.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual registered module list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMListRegisteredModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the store context used in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned store context links to the store in the VM context and owned by&quot;</span>] # [doc = <span class="string">&quot; the VM context. This function will return NULL if error occurs. The caller&quot;</span>] # [doc = <span class="string">&quot; should __NOT__ call the `WasmEdge_StoreDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the store context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetStoreContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_StoreContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the loader context used in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned loader context links to the loader in the VM context and owned&quot;</span>] # [doc = <span class="string">&quot; by the VM context. This function will return NULL if error occurs. The&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_LoaderDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the loader context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetLoaderContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_LoaderContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the validator context used in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned validator context links to the validator in the VM context and&quot;</span>] # [doc = <span class="string">&quot; owned by the VM context. This function will return NULL if error occurs. The&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_ValidatorDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the validator context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetValidatorContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ValidatorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the executor context used in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned executor context links to the executor in the VM context and&quot;</span>] # [doc = <span class="string">&quot; owned by the VM context. This function will return NULL if error occurs. The&quot;</span>] # [doc = <span class="string">&quot; caller should __NOT__ call the `WasmEdge_ExecutorDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the executor context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetExecutorContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the statistics context used in the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The statistics context links to the statistics in the VM context and owned&quot;</span>] # [doc = <span class="string">&quot; by the VM context. The caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_StatisticsDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function is thread-safe.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the statistics context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetStatisticsContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_StatisticsContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_VMContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After calling this function, the context will be destroyed and should&quot;</span>] # [doc = <span class="string">&quot; __NOT__ be used.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_VMContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Entrypoint for the compiler tool.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function provides an entrypoint to the WasmEdge AOT compiler tool with&quot;</span>] # [doc = <span class="string">&quot; the command line arguments.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Argc the argument count.&quot;</span>] # [doc = <span class="string">&quot; \\param Argv the argument vector.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the execution status.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Driver_Compiler (Argc : :: std :: os :: raw :: c_int , Argv : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Entrypoint for the runtime tool.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; This function provides an entrypoint to the WasmEdge runtime tool with the&quot;</span>] # [doc = <span class="string">&quot; command line arguments.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Argc the argument count.&quot;</span>] # [doc = <span class="string">&quot; \\param Argv the argument vector.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the execution status.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Driver_Tool (Argc : :: std :: os :: raw :: c_int , Argv : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load plugins with the default search paths.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The default paths are:&quot;</span>] # [doc = <span class="string">&quot;   1. The environment variable \&quot;WASMEDGE_PLUGIN_PATH\&quot;.&quot;</span>] # [doc = <span class="string">&quot;   2. The \&quot;../plugin/\&quot; directory related to the WasmEdge installation path.&quot;</span>] # [doc = <span class="string">&quot;   3. The \&quot;wasmedge/\&quot; directory under the library path if the WasmEdge is&quot;</span>] # [doc = <span class="string">&quot;      installed under the \&quot;/usr\&quot;.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginLoadWithDefaultPaths () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the plugin with the given file or directory.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; For the given file path, this function will load the plug-in.&quot;</span>] # [doc = <span class="string">&quot; For the given directory path, this function will load the plug-ins under the&quot;</span>] # [doc = <span class="string">&quot; directory recursively.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Path the path to plug-in file or directory.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginLoadFromPath (Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of loaded plug-in list.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of loaded plug-in list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListPluginsLength () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the loaded plug-ins with their names.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned plug-in names filled into the `Names` array are owned by the&quot;</span>] # [doc = <span class="string">&quot; internal WasmEdge plug-in storage, and the caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the loaded&quot;</span>] # [doc = <span class="string">&quot; plug-in list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the function names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual loaded plug-in list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListPlugins (Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Find the loaded plug-in context by name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; After loading the plug-ins from default paths or the given path, developers&quot;</span>] # [doc = <span class="string">&quot; can use this API to retrieve the plug-in context by name. Then developers&quot;</span>] # [doc = <span class="string">&quot; can create the module instance from the plug-in contexts.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Name the plug-in name WasmEdge_String.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the plug-in context. NULL if the plug-in not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginFind (Name : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_PluginContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the plug-in name of the plug-in context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned string object is linked to the plug-in name of the plug-in&quot;</span>] # [doc = <span class="string">&quot; context, and the caller should __NOT__ call the `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_PluginContext.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginGetPluginName (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of module list in the plug-in context.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; There may be several modules in a plug-in. Developers can use this function&quot;</span>] # [doc = <span class="string">&quot; to get the length of the module list in a plug-in.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_PluginContext to get the length of the module list.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns length of module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the modules in the plug-in context with their names.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; The returned module names filled into the `Names` array are owned by the&quot;</span>] # [doc = <span class="string">&quot; internal WasmEdge plug-in storage, and the caller should __NOT__ call the&quot;</span>] # [doc = <span class="string">&quot; `WasmEdge_StringDelete`.&quot;</span>] # [doc = <span class="string">&quot; If the `Names` buffer length is smaller than the result of the loaded&quot;</span>] # [doc = <span class="string">&quot; plug-in list size, the overflowed return values will be discarded.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_PluginContext to list the modules.&quot;</span>] # [doc = <span class="string">&quot; \\param [out] Names the output WasmEdge_String buffer of the function names.&quot;</span>] # [doc = <span class="string">&quot; \\param Len the buffer length.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns actual module list size of the plug-in.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListModule (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Create the module instance in the plug-in by the module name.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; By giving the module name, developers can retrieve the module in the plug-in&quot;</span>] # [doc = <span class="string">&quot; and create the module instance.&quot;</span>] # [doc = <span class="string">&quot; The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`&quot;</span>] # [doc = <span class="string">&quot; to destroy it.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\param Cxt the WasmEdge_PluginContext to retrieve and create module.&quot;</span>] # [doc = <span class="string">&quot; \\param ModuleName the module name to retrieve.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns pointer to the module instance context, NULL if the module name not&quot;</span>] # [doc = <span class="string">&quot; found in the plug-in or the plug-in is not valid.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginCreateModule (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext , ModuleName : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Implement by plugins for returning the plugin descriptor.&quot;</span>] # [doc = <span class="string">&quot;&quot;</span>] # [doc = <span class="string">&quot; \\returns the plugin descriptor.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Plugin_GetDescriptor () -&gt; * <span class="kw">const </span>WasmEdge_PluginDescriptor ; }</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="wasmedge_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.2 (9eb3afe9e 2023-03-27)" data-search-js="search-98d53477a794af0b.js" data-settings-js="settings-c3c521c753752a1a.js" data-settings-css="settings-08ddfdda51b8ee2e.css" ></div></body></html>