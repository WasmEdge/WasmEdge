# syntax=docker/dockerfile:1.5-labs

ARG ALPINE_VERSION=3.22

########################################
# Stage 1: Cross-compilation tool
########################################
FROM --platform=$BUILDPLATFORM tonistiigi/xx:1.2.1 AS xx

########################################
# Stage 2: Build LLD from LLVM source
########################################
FROM alpine:${ALPINE_VERSION} AS lld-builder

RUN apk add --no-cache \
    bash \
    cmake \
    ninja \
    clang \
    llvm-dev \
    llvm-static \
    lld-dev \
    git \
    musl-dev \
    zlib-dev \
    zlib-static \
    libc-dev \
    libffi-dev \
    curl \
    tar \
    xz \
    zstd-dev \
    zstd-static \
    file \
    python3

WORKDIR /lld-build

RUN git clone --depth=1 --branch=release/18.x https://github.com/llvm/llvm-project.git

WORKDIR /lld-build/llvm-project

RUN cmake -B build \
    -G Ninja \
    -DLLVM_ENABLE_PROJECTS="clang;llvm;lld" \
    -DLLVM_TARGETS_TO_BUILD="X86;WebAssembly" \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_INSTALL_PREFIX=/lld-install \
    -DCMAKE_INSTALL_LIBDIR=lib \
    -DLLVM_ENABLE_ASSERTIONS=OFF \
    -DLLVM_INCLUDE_TOOLS=ON \
    -DLLVM_TOOL_LLVM_AR_BUILD=ON \
    -DLLVM_TOOL_LLVM_NM_BUILD=ON \
    -DLLVM_TOOL_LLVM_RANLIB_BUILD=ON \
    -DLLVM_TOOL_LLVM_TBLGEN_BUILD=ON \
    -DLLVM_TOOL_LLVM_PROFDATA_BUILD=ON \
    -DLLVM_TOOL_LTO_BUILD=ON \
    -DLLVM_TOOL_BUGPOINT_BUILD=ON \
    -DLLVM_TOOL_LLVM_BCANALYZER_BUILD=ON \
    -DLLVM_TOOL_LLI_BUILD=ON \
    llvm

RUN cmake --build build --target install

# Copy all built tools, even if not installed via 'install' target
RUN find build/bin -type f -executable -exec cp -v {} /lld-install/bin/ \;

# Confirm lli is present
RUN test -f /lld-install/bin/lli || (echo "Error: lli not installed!" && false)

########################################
# Stage 3: Alpine Static Image with LLD and a Robust Toolchain
########################################
FROM --platform=$BUILDPLATFORM alpine:${ALPINE_VERSION} AS alpine-static

COPY --from=xx /usr/bin/xx* /usr/bin/
RUN apk add --no-cache bash

SHELL ["bash", "-c"]

# CRITICAL FIX: Do not install g++, as it creates a standard library conflict.
RUN apk add --no-cache \
    cmake \
    samurai \
    clang \
    llvm-static \
    lld-dev \
    zlib-static \
    zlib-dev \
    git \
    musl-dev \
    libc-dev \
    libffi-dev

RUN mkdir -p /usr/lib/llvm/lib /usr/lib/cmake/llvm $(xx-info sysroot)/usr/bin

COPY --from=lld-builder /lld-install/lib/ /usr/lib/
COPY --from=lld-builder /lld-install/bin/ /usr/bin/
COPY --from=lld-builder /lld-install/lib/cmake/ /usr/lib/cmake/

RUN if xx-info is-cross; then cp -f /usr/bin/* $(xx-info sysroot)/usr/bin/; fi

# Copy libLTO shared libraries
COPY --from=lld-builder /lld-install/lib/libLTO.so* /usr/lib/
RUN if xx-info is-cross; then cp -f /usr/lib/libLTO.so* $(xx-info sysroot)/usr/lib/; fi

# Patch LLVMConfig for proper sysroot awareness
RUN sed -i 's|/usr/lib/llvm|${CMAKE_SYSROOT}usr/lib/llvm|' $(xx-info sysroot)usr/lib/cmake/llvm*/LLVMConfig.cmake || true

# Create a comprehensive, robust toolchain file generator
RUN cat <<'EOT' > /usr/bin/xx-toolchain && chmod +x /usr/bin/xx-toolchain
#!/bin/bash
set -e
SYSROOT=$(xx-info sysroot)
TARGET_TRIPLE=$(xx-clang --print-target-triple)
TOOLCHAIN_FILE="/etc/xx-toolchains/${TARGET_TRIPLE}.cmake"

# Only generate the file if it doesn't exist
if [ ! -f "$TOOLCHAIN_FILE" ]; then
    mkdir -p "$(dirname "$TOOLCHAIN_FILE")"
    echo "--- Generating CMake toolchain file for ${TARGET_TRIPLE} ---" >&2
    cat <<EOF > "$TOOLCHAIN_FILE"
# CMake Toolchain File for ${TARGET_TRIPLE}

set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR "$(xx-info arch)")
set(CMAKE_SYSROOT "${SYSROOT}")

set(CMAKE_C_COMPILER "$(which xx-clang)")
set(CMAKE_CXX_COMPILER "$(which xx-clang++)")
set(CMAKE_ASM_COMPILER "$(which xx-clang)")

set(CMAKE_LINKER "$(which xx-clang++)")
set(CMAKE_AR "$(which xx-llvm-ar)")
set(CMAKE_RANLIB "$(which xx-llvm-ranlib)")

# FINAL FIX: Use -nostdinc++ to prevent the compiler from using its broken default C++ include paths.
# We then manually add the correct paths in the correct order. This is the most forceful and reliable way
# to fix the header search path and macro collision errors.
set(CMAKE_CXX_FLAGS "--sysroot=${SYSROOT} -stdlib=libc++ -pthread -D_GNU_SOURCE -nostdinc++ -isystem \${SYSROOT}/usr/include/c++/v1 -isystem \${SYSROOT}/usr/include" CACHE STRING "C++ compiler flags")
set(CMAKE_C_FLAGS "--sysroot=${SYSROOT} -pthread -D_GNU_SOURCE -isystem \${SYSROOT}/usr/include" CACHE STRING "C compiler flags")

# Linker flags.
set(COMMON_LINKER_FLAGS "--sysroot=\${SYSROOT} -stdlib=libc++ -fuse-ld=lld -L\${SYSROOT}/usr/lib -lunwind")
set(CMAKE_EXE_LINKER_FLAGS    "\${COMMON_LINKER_FLAGS}" CACHE STRING "Executable linker flags")
set(CMAKE_SHARED_LINKER_FLAGS "\${COMMON_LINKER_FLAGS}" CACHE STRING "Shared linker flags")
set(CMAKE_MODULE_LINKER_FLAGS "\${COMMON_LINKER_FLAGS}" CACHE STRING "Module linker flags")

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
EOF
fi
echo "$TOOLCHAIN_FILE"
EOT

########################################
# Stage 4: wasmedge-build with the robust toolchain
########################################
FROM alpine-static AS wasmedge-build

ARG TARGETPLATFORM
ARG ALPINE_VERSION

WORKDIR /src_writable
SHELL ["bash", "-c"]

# Host tools
RUN apk add --no-cache \
    curl \
    tar \
    git \
    ninja \
    bash \
    cmake \
    zstd-dev \
    zstd-static

# Install a clean libc++ toolchain into the sysroot.
# Do NOT install g++, as it brings in a conflicting libstdc++ implementation.
RUN xx-apk add \
    musl-dev \
    libc-dev \
    clang \
    libc++-static \
    libc++-dev \
    llvm-libunwind-static

# Fake dsymutil for CMake sanity
RUN ln -sf /bin/true /usr/bin/dsymutil

# Sanity checks
RUN test -f "$(xx-info sysroot)/usr/include/stdlib.h" || (echo "stdlib.h not found in sysroot!" && false)
RUN test -f "$(xx-info sysroot)/usr/include/c++/v1/vector" || (echo "libc++ headers not found in sysroot!" && false)

# Copy the read-only mounted source to a writable location, then patch and build from there.
RUN --mount=type=bind,target=/src,source=.,ro \
    set -e && \
    echo "Creating a writable copy of the source code..." && \
    cp -r /src/. . && \
    echo "Patching for older Alpine compatibility..." && \
    sed -i '1i#include <fcntl.h>\n#ifndef O_SYMLINK\n#define O_SYMLINK O_NOFOLLOW\n#endif' lib/host/wasi/inode-linux.cpp && \
    echo "Configuring with CMake..." && \
    cmake -S . -B /build -G Ninja \
        -DCMAKE_BUILD_TYPE=MinSizeRel \
        -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
        -DCMAKE_INSTALL_PREFIX="/install" \
        -DCMAKE_TOOLCHAIN_FILE="$(xx-toolchain)" \
        -DCMAKE_PREFIX_PATH="$(xx-info sysroot)/usr/lib/cmake/llvm" \
        -DWASMEDGE_BUILD_PACKAGE="TGZ" \
        -DWASMEDGE_USE_LLVM=ON \
        -DWASMEDGE_BUILD_STATIC_LIB=ON \
        -DWASMEDGE_BUILD_TESTS=OFF \
        -DWASMEDGE_BUILD_SHARED_LIB=OFF \
        -DWASMEDGE_BUILD_TOOLS=OFF \
        -DWASMEDGE_BUILD_PLUGINS=OFF \
        -DWASMEDGE_BUILD_EXAMPLE=OFF \
        -DWASMEDGE_LINK_LLVM_STATIC=ON \
        -DWASMEDGE_LINK_TOOLS_STATIC=ON \
        -DWASMEDGE_DISABLE_LIBTINFO=ON && \
    echo "Building with CMake..." && \
    cmake --build /build -- install package

CMD ["/bin/bash"]
